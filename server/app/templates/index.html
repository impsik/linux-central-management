<!doctype html>
<html>

<head>
  <meta charset="utf-8">
  <title>Fleet Management</title>
  <script>
    // Theme bootstrap: set before paint
    (function () {
      try {
        const saved = localStorage.getItem('fleet_theme');
        const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        const theme = saved || (prefersDark ? 'dark' : 'light');
        document.documentElement.dataset.theme = theme;
      } catch (e) {
        document.documentElement.dataset.theme = 'dark';
      }
    })();
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm/css/xterm.css" />
  <script src="https://cdn.jsdelivr.net/npm/xterm/lib/xterm.js"></script>
  <script src="/assets/fleet-phase3.js"></script>
  <script src="/assets/fleet-phase3-mfa.js"></script>
  <script src="/assets/fleet-phase3-auth-ui.js"></script>
  <link rel="stylesheet" href="/assets/index-MnFIflNy.css" />
  <link rel="stylesheet" href="/assets/fleet-ui.css" />
</head>

<body>
  <div class="header">
    <div class="header-title">
      <h1 id="app-title">Fleet Management</h1>
    </div>
    <div class="header-actions">
      <div class="header-user">
        <div class="header-subtitle" id="current-user">Signed in</div>
        <div class="settings-menu" id="settings-menu-wrap">
          <button class="icon-btn" id="theme-toggle" type="button" title="Toggle theme" aria-label="Toggle theme">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path
                d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-16a1 1 0 0 1 1 1v1a1 1 0 1 1-2 0V3a1 1 0 0 1 1-1zm0 18a1 1 0 0 1 1 1v1a1 1 0 1 1-2 0v-1a1 1 0 0 1 1-1zM4.22 5.64a1 1 0 0 1 1.41 0l.7.7A1 1 0 1 1 4.92 7.75l-.7-.7a1 1 0 0 1 0-1.41zm12.45 12.45a1 1 0 0 1 1.41 0l.7.7a1 1 0 1 1-1.41 1.41l-.7-.7a1 1 0 0 1 0-1.41zM2 12a1 1 0 0 1 1-1h1a1 1 0 1 1 0 2H3a1 1 0 0 1-1-1zm18 0a1 1 0 0 1 1-1h1a1 1 0 1 1 0 2h-1a1 1 0 0 1-1-1zM4.22 18.36a1 1 0 0 1 0-1.41l.7-.7a1 1 0 1 1 1.41 1.41l-.7.7a1 1 0 0 1-1.41 0zM16.67 5.91a1 1 0 0 1 0-1.41l.7-.7a1 1 0 1 1 1.41 1.41l-.7.7a1 1 0 0 1-1.41 0z" />
            </svg>
          </button>
          <button class="icon-btn" id="settings-btn" type="button" aria-haspopup="true" aria-expanded="false"
            aria-controls="settings-dropdown" title="Settings">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path
                d="M19.14 12.94c.04-.3.06-.61.06-.94s-.02-.64-.06-.94l2.03-1.58a.5.5 0 0 0 .12-.64l-1.92-3.32a.5.5 0 0 0-.6-.22l-2.39.96a7.47 7.47 0 0 0-1.63-.94l-.36-2.54A.5.5 0 0 0 13.9 1h-3.8a.5.5 0 0 0-.49.41l-.36 2.54a7.47 7.47 0 0 0-1.63.94l-2.39-.96a.5.5 0 0 0-.6.22L2.71 7.97a.5.5 0 0 0 .12.64l2.03 1.58c-.04.3-.06.62-.06.94s.02.64.06.94L2.83 13.65a.5.5 0 0 0-.12.64l1.92 3.32a.5.5 0 0 0 .6.22l2.39-.96c.5.39 1.05.72 1.63.94l.36 2.54a.5.5 0 0 0 .49.41h3.8a.5.5 0 0 0 .49-.41l.36-2.54c.58-.22 1.13-.55 1.63-.94l2.39.96a.5.5 0 0 0 .6-.22l1.92-3.32a.5.5 0 0 0-.12-.64l-2.03-1.58zM12 15.5A3.5 3.5 0 1 1 12 8a3.5 3.5 0 0 1 0 7.5z" />
            </svg>
          </button>
          <div class="settings-dropdown" id="settings-dropdown" role="menu">
            <button class="settings-item" id="admin-menu-item" type="button" role="menuitem">Admin</button>
            <button class="settings-item" id="logout-btn" type="button" role="menuitem">Logout</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="container">
    <div class="sidebar">
      <div class="sidebar-header">Hosts management</div>
      <div class="sidebar-content">
        <div class="host-filters">
          <input id="host-search" class="host-search" type="text" placeholder="Search hosts (name, id, IP)..." />

          <div class="filter-section" id="labels-filter-section">
            <div class="filter-section-header" id="labels-filter-toggle">
              <div class="filter-section-title">Label filters</div>
              <button class="filter-toggle" type="button" aria-expanded="false" aria-controls="labels-filter-body"
                id="labels-toggle-btn">+</button>
            </div>

            <div class="filter-section-body" id="labels-filter-body">
              <div class="vuln-row">
                <select id="label-env" class="host-search">
                  <option value="">Env: Any</option>
                </select>
              </div>
              <div class="vuln-row">
                <select id="label-role" class="host-search">
                  <option value="">Role: Any</option>
                </select>
              </div>
              <div class="vuln-actions">
                <button class="btn" id="labels-clear">Clear</button>
              </div>
            </div>
          </div>

          <div class="filter-section" id="vuln-filter-section">
            <div class="filter-section-header" id="vuln-filter-toggle">
              <div class="filter-section-title">Vulnerability filter</div>
              <button class="filter-toggle" type="button" aria-expanded="false" aria-controls="vuln-filter-body"
                id="vuln-toggle-btn">+</button>
            </div>

            <div class="filter-section-body" id="vuln-filter-body">
              <div class="vuln-filter">
                <div class="vuln-row">
                  <input id="vuln-cve" class="host-search" type="text" placeholder="CVE (e.g. CVE-2021-45105)" />
                </div>
                <div class="vuln-row">
                  <input id="vuln-package" class="host-search" type="text" placeholder="Package name (e.g. openssl)" />
                </div>
                <div class="vuln-row">
                  <input id="vuln-version" class="host-search" type="text"
                    placeholder="Vulnerable version (exact, e.g. 1.1.1w-0+deb11u1)" />
                </div>
                <div class="vuln-actions">
                  <button class="btn btn-primary" id="vuln-apply">Show vulnerable</button>
                  <button class="btn" id="vuln-clear" disabled>Clear</button>
                </div>
                <div class="vuln-status" id="vuln-status"></div>

                <div class="vuln-upgrade">
                  <label class="vuln-inline">
                    <input type="checkbox" id="select-visible-hosts" />
                    Select all visible hosts
                  </label>

                  <div id="cve-packages-panel" style="display:none;margin:0.5rem 0 0.25rem 0;">
                    <div style="font-size:0.85rem;color:#94a3b8;margin-bottom:0.25rem;">Affected packages (CVE)</div>
                    <div id="cve-packages-list" style="display:flex;flex-direction:column;gap:0.25rem;max-height:220px;overflow:auto;padding:0.25rem 0.25rem;border:1px solid #2d3748;border-radius:8px;"></div>
                    <div id="cve-plan-summary" style="font-size:0.8rem;color:#94a3b8;margin-top:0.35rem;"></div>
                    <div style="font-size:0.8rem;color:#94a3b8;margin-top:0.25rem;">We’ll upgrade the selected packages on each selected host, but only if that host reported the package as affected.</div>
                  </div>

                  <button class="btn btn-primary" id="upgrade-selected" disabled>Upgrade selected</button>
                  <div class="vuln-status" id="upgrade-status"></div>
                </div>
              </div>
            </div>
          </div>

          <div class="filter-section" id="ansible-filter-section">
            <div class="filter-section-header" id="ansible-filter-toggle">
              <div class="filter-section-title">Ansible</div>
              <button class="filter-toggle" type="button" aria-expanded="false" aria-controls="ansible-filter-body"
                id="ansible-toggle-btn">+</button>
            </div>
            <div class="filter-section-body" id="ansible-filter-body">
              <div class="vuln-row">
                <select id="ansible-playbook" class="host-search">
                  <option value="">Select playbook</option>
                </select>
              </div>
              <div class="vuln-actions">
                <button class="btn btn-primary" id="ansible-open" disabled>Configure & Run</button>
                <button class="btn" id="ansible-refresh">Refresh</button>
              </div>
              <div class="vuln-status" id="ansible-status"></div>
            </div>
          </div>
        </div>

        <div id="hosts">
          <div class="loading">Loading hosts...</div>
        </div>
      </div>
    </div>

    <div class="main-content">
      <div class="host-actions" id="host-actions" style="display: none;">
        <button class="btn btn-primary host-action-btn" id="host-action-terminal" type="button">Terminal</button>
        <button class="btn btn-primary host-action-btn" id="host-action-users" type="button">Users</button>
        <button class="btn btn-primary host-action-btn" id="host-action-services" type="button">Services</button>
        <button class="btn btn-primary host-action-btn" id="host-action-packages" type="button">Packages</button>
      </div>

      <div class="host-actions" id="fleet-actions" style="display: flex; gap: 0.5rem; margin-bottom: 0.75rem;">
        <button class="btn" id="nav-overview" type="button">Overview</button>
        <button class="btn" id="nav-hosts" type="button">Hosts</button>
        <button class="btn" id="nav-cronjobs" type="button">Cronjobs</button>
        <button class="btn" id="nav-sshkeys" type="button">SSH Keys <span id="sshkeys-approval-indicator" title="Pending approvals" style="display:none;color:#ef4444;font-weight:900;margin-left:6px;">!</span></button>
      </div>



      <!-- Server Info / Overview View -->
      <div class="tab-content-custom active" id="server-info-tab">
        <div class="server-info-content">
          <div id="server-info-header" style="display: none;">
            <div class="server-info-title">
              <div>
                <h2 id="server-info-hostname">Server Name</h2>
                <div id="server-info-details" class="server-info-details"></div>
                <div id="server-info-labels" class="label-badges"></div>
              </div>
            </div>

            <div class="metrics-grid">
              <div class="metric-card" id="disk-card" title="Click for df -h details" style="cursor:pointer;">
                <div class="metric-label">Disk Usage</div>
                <div class="metric-value" id="disk-usage">-</div>
                <div class="metric-details" id="disk-details">-</div>
                <div class="metric-bar">
                  <div class="metric-bar-fill" id="disk-bar" style="width: 0%"></div>
                </div>
              </div>

              <div class="metric-card">
                <div class="metric-label">Memory</div>
                <div class="metric-value" id="memory-usage">-</div>
                <div class="metric-details" id="memory-details">-</div>
                <div class="metric-bar">
                  <div class="metric-bar-fill" id="memory-bar" style="width: 0%"></div>
                </div>
              </div>

              <div class="metric-card">
                <div class="metric-label">vCPUs</div>
                <div class="metric-value" id="vcpus">-</div>
                <div class="metric-details">CPU Cores</div>
              </div>

              <div class="metric-card">
                <div class="metric-label">IP Addresses</div>
                <div class="metric-value" id="ip-addresses">-</div>
                <div class="metric-details" id="ip-list"></div>
              </div>
            </div>

            <div class="load-graph-container">
              <div style="display:flex;align-items:center;justify-content:space-between;gap:1rem;flex-wrap:wrap;">
                <div class="metric-label" style="margin-bottom:0;">System Load (1 min average)</div>
                <div style="display:flex;align-items:center;gap:0.5rem;">
                  <span style="font-size:0.85rem;color:#718096;">Timeframe</span>
                  <select id="load-timeframe" class="host-search" style="width:auto;padding:0.35rem 0.5rem;">
                    <option value="300">5m</option>
                    <option value="900">15m</option>
                    <option value="3600" selected>1h</option>
                    <option value="21600">6h</option>
                    <option value="86400">24h</option>
                    <option value="604800">7d</option>
                  </select>
                </div>
              </div>
              <canvas id="load-graph"></canvas>
              <div style="margin-top: 1rem;">
                <div class="metric-label">Top Processes (CPU)</div>
                <div style="overflow-x: auto;">
                  <table class="process-table">
                    <thead>
                      <tr>
                        <th>PID</th>
                        <th>User</th>
                        <th>CPU %</th>
                        <th>MEM %</th>
                        <th>Command</th>
                      </tr>
                    </thead>
                    <tbody id="top-processes-body">
                      <tr>
                        <td colspan="5" style="text-align:center;color:#a0aec0;">Loading...</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>

          <div id="server-info-placeholder" class="empty-state" style="text-align:left;max-width:none;">
            <div style="display:flex;align-items:flex-end;justify-content:space-between;gap:1rem;flex-wrap:wrap;">
              <div>
                <h2 style="margin:0 0 0.25rem 0;">Fleet Overview</h2>
                <div style="color:#94a3b8;font-size:0.95rem;">Live posture across your fleet. Click any tile to drill
                  down.</div>
              </div>
              <div style="display:flex;gap:0.5rem;flex-wrap:wrap;">
                <button class="btn" id="overview-refresh" type="button">Refresh</button>
                <button class="btn btn-primary" id="overview-inventory-now" type="button">Inventory now
                  (visible)</button>
                <button class="btn btn-primary" id="overview-security-campaign" type="button">Security campaign</button>
                <button class="btn" id="overview-dist-upgrade" type="button">Full upgrade (dist-upgrade)</button>
              </div>
            </div>

            <div class="metrics-grid" style="margin-top:1rem;">
              <div class="metric-card" id="kpi-hosts-online" style="cursor:pointer;">
                <div class="metric-label">Hosts online</div>
                <div class="metric-value" id="kpi-online">–</div>
                <div class="metric-details" id="kpi-online-details">–</div>
              </div>
              <div class="metric-card" id="kpi-security" style="cursor:pointer;">
                <div class="metric-label">Security updates pending</div>
                <div class="metric-value" id="kpi-sec">–</div>
                <div class="metric-details" id="kpi-sec-details">–</div>
              </div>
              <div class="metric-card" id="kpi-updates" style="cursor:pointer;">
                <div class="metric-label">All updates pending</div>
                <div class="metric-value" id="kpi-upd">–</div>
                <div class="metric-details" id="kpi-upd-details">–</div>
              </div>
              <div class="metric-card" id="kpi-failures" style="cursor:pointer;">
                <div class="metric-label">Failed runs (24h)</div>
                <div class="metric-value" id="kpi-fail">–</div>
                <div class="metric-details" id="kpi-fail-details">Jobs / campaigns</div>
              </div>
            </div>

            <div style="display:grid;grid-template-columns:1.35fr 1fr;gap:1rem;margin-top:1rem;align-items:start;">
              <div class="admin-card" style="margin:0;">
                <div class="admin-card-title">Attention required</div>
                <div class="admin-card-body">
                  <div id="overview-attention" style="color:#cbd5e1;">Loading…</div>
                </div>
              </div>
              <div class="admin-card" style="margin:0;">
                <div class="admin-card-title">Data freshness</div>
                <div class="admin-card-body">
                  <div style="display:flex;flex-direction:column;gap:0.35rem;">
                    <div><span style="color:#94a3b8;">Last updates check:</span> <span id="kpi-fresh">–</span></div>
                    <div style="color:#94a3b8;font-size:0.9rem;">Online is based on last_seen within grace window.</div>
                    <div style="color:#94a3b8;font-size:0.9rem;">Reboot-required is not yet centralized
                      (per-host/campaign).</div>
                  </div>
                </div>
              </div>
            </div>


            <div class="admin-card" id="failed-runs-card" style="margin-top:1rem;">
              <div class="admin-card-title" style="display:flex;align-items:center;justify-content:space-between;gap:1rem;flex-wrap:wrap;">
                <span>Failed runs (24h)</span>
                <button class="btn" id="failed-runs-refresh" type="button">Reload</button>
              </div>
              <div class="admin-card-body">
                <div style="overflow-x:auto;">
                  <table class="process-table" style="min-width:900px;">
                    <thead>
                      <tr>
                        <th>When</th>
                        <th>Host</th>
                        <th>Job</th>
                        <th style="text-align:right;">Exit</th>
                        <th>Error</th>
                      </tr>
                    </thead>
                    <tbody id="overview-failed-runs">
                      <tr><td colspan="5" style="text-align:center;color:#a0aec0;">Loading…</td></tr>
                    </tbody>
                  </table>
                </div>
                <div class="admin-note" style="margin-top:0.5rem;">Click a row to view stderr/stdout.</div>
              </div>
            </div>
            <div class="admin-card" style="margin-top:1rem;">
              <div class="admin-card-title"
                style="display:flex;align-items:center;justify-content:space-between;gap:1rem;flex-wrap:wrap;">
                <span>Pending updates report</span>
                <div style="display:flex;gap:0.5rem;align-items:center;flex-wrap:wrap;">
                  <label style="color:#94a3b8;font-size:0.9rem;">Sort</label>
                  <select id="report-sort" class="host-search" style="width:auto;padding:0.35rem 0.5rem;">
                    <option value="security_updates" selected>Security updates</option>
                    <option value="updates">All updates</option>
                    <option value="os_version">OS version</option>
                    <option value="hostname">Hostname</option>
                    <option value="last_seen">Last seen</option>
                  </select>
                  <select id="report-order" class="host-search" style="width:auto;padding:0.35rem 0.5rem;">
                    <option value="desc" selected>Desc</option>
                    <option value="asc">Asc</option>
                  </select>
                  <a class="btn" id="report-download-html" href="/reports/hosts-updates.html" target="_blank"
                    rel="noopener">Download HTML</a>
                  <button class="btn" id="report-refresh" type="button">Reload report</button>
                </div>
              </div>
              <div class="admin-card-body">
                <div style="overflow-x:auto;">
                  <table class="process-table" style="min-width:900px;">
                    <thead>
                      <tr>
                        <th id="th-host" class="sortable-col" title="Sort by host" aria-sort="none" tabindex="0" role="button">
                          Host <span class="sort-indicator" aria-hidden="true">↕</span></th>
                        <th id="th-os" class="sortable-col" title="Sort by OS" aria-sort="none" tabindex="0" role="button">
                          OS <span class="sort-indicator" aria-hidden="true">↕</span></th>
                        <th>Kernel</th>
                        <th>Security</th>
                        <th id="th-updates" class="sortable-col" title="Sort by all updates" aria-sort="none" tabindex="0" role="button">
                          All updates <span class="sort-indicator" aria-hidden="true">↕</span></th>
                        <th>Online</th>
                        <th>Last seen</th>
                      </tr>
                    </thead>
                    <tbody id="overview-updates-report">
                      <tr>
                        <td colspan="7" style="text-align:center;color:#a0aec0;">Loading…</td>
                      </tr>
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

    <div class="tab-content-custom" id="hosts-table-tab">
      <div class="server-info-content" style="padding-top:0;">
        <div style="display:flex;align-items:flex-end;justify-content:space-between;gap:1rem;flex-wrap:wrap;">
          <div>
            <h2 style="margin:0 0 0.25rem 0;">Hosts</h2>
            <div style="color:#94a3b8;font-size:0.95rem;">Sortable fleet table (updates, security, reboot-needed).
              Select rows for bulk actions.</div>
          </div>
          <div style="display:flex;gap:0.5rem;align-items:center;flex-wrap:wrap;">
            <label style="color:#94a3b8;font-size:0.9rem;">Sort</label>
            <select id="hosts-sort" class="host-search" style="width:auto;padding:0.35rem 0.5rem;">
              <option value="hostname" selected>Host</option>
              <option value="os_version">OS</option>
              <option value="updates">All updates</option>
              <option value="security_updates">Security updates</option>
              <option value="last_seen">Last seen</option>
            </select>
            <select id="hosts-order" class="host-search" style="width:auto;padding:0.35rem 0.5rem;">
              <option value="asc" selected>Asc</option>
              <option value="desc">Desc</option>
            </select>
            <button class="btn" id="hosts-reload" type="button">Reload</button>
            <button class="btn" id="hosts-cleanup-offline" type="button" title="Delete hosts that have been offline for a while">Clean offline…</button>
          </div>
        </div>

        <div style="display:flex;gap:0.5rem;flex-wrap:wrap;margin-top:0.75rem;">
          <button class="btn btn-primary" id="hosts-bulk-inventory" type="button">Inventory now (selected)</button>
          <button class="btn btn-primary" id="hosts-bulk-security" type="button">Security campaign (selected)</button>
          <button class="btn" id="hosts-bulk-dist" type="button">dist-upgrade (selected)</button>
          <span id="hosts-bulk-status" style="color:#94a3b8;font-size:0.9rem;"></span>
        </div>

        <div class="hosts-table-wrap" style="margin-top:0.75rem;">
          <table class="process-table hosts-table">
            <thead>
              <tr>
                <th style="width:36px;"><input type="checkbox" id="hosts-select-all" /></th>
                <th class="sortable-col" id="hosts-th-host" title="Sort by host" tabindex="0" role="button">Host <span class="sort-indicator" aria-hidden="true">↕</span></th>
                <th class="sortable-col" id="hosts-th-os" title="Sort by OS" tabindex="0" role="button">OS <span class="sort-indicator" aria-hidden="true">↕</span></th>
                <th>Kernel</th>
                <th class="sortable-col" style="text-align:right;" id="hosts-th-sec" title="Sort by security updates" tabindex="0" role="button">Security <span class="sort-indicator" aria-hidden="true">↕</span></th>
                <th class="sortable-col" style="text-align:right;" id="hosts-th-upd" title="Sort by all updates" tabindex="0" role="button">All updates <span class="sort-indicator" aria-hidden="true">↕</span></th>
                <th>Reboot</th>
                <th>Online</th>
                <th class="sortable-col" id="hosts-th-last" title="Sort by last seen" tabindex="0" role="button">Last seen <span class="sort-indicator" aria-hidden="true">↕</span></th>
              </tr>
            </thead>
            <tbody id="hosts-table-body">
              <tr>
                <td colspan="9" style="text-align:center;color:#a0aec0;">Loading…</td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>


    <div class="tab-content-custom" id="cronjobs-tab">
      <div class="admin-content">
        <div class="section-title">Cronjobs</div>
        <div class="admin-note" style="margin-bottom:0.75rem;">One-shot scheduled actions (safe mode). Runs as the agent job type (e.g. dist-upgrade uses sudo on the host).</div>

        <div class="admin-card" style="margin-bottom:1rem;">
          <div class="admin-card-title">Create cronjob</div>
          <div class="admin-card-body">
            <div style="display:flex;gap:0.75rem;flex-wrap:wrap;align-items:flex-end;">
              <div style="min-width:220px;flex:1;">
                <label style="display:block;color:var(--muted-2);font-size:0.85rem;margin-bottom:0.25rem;">Name (optional)</label>
                <input id="cron-name" class="host-search" type="text" placeholder="e.g. weekly dist-upgrade" />
              </div>
              <div style="min-width:220px;">
                <label style="display:block;color:var(--muted-2);font-size:0.85rem;margin-bottom:0.25rem;">Run at (your local time)</label>
                <input id="cron-run-at" class="host-search" type="datetime-local" />
              </div>
              <div style="min-width:220px;">
                <label style="display:block;color:var(--muted-2);font-size:0.85rem;margin-bottom:0.25rem;">Schedule</label>
                <select id="cron-schedule-kind" class="host-search">
                  <option value="once" selected>Once</option>
                  <option value="daily">Daily</option>
                  <option value="weekly">Weekly</option>
                  <option value="monthly">Monthly</option>
                </select>
              </div>
              <div style="min-width:220px;display:none;" id="cron-weekday-wrap">
                <label style="display:block;color:var(--muted-2);font-size:0.85rem;margin-bottom:0.25rem;">Weekday</label>
                <select id="cron-weekday" class="host-search">
                  <option value="0">Mon</option><option value="1">Tue</option><option value="2">Wed</option><option value="3">Thu</option><option value="4">Fri</option><option value="5">Sat</option><option value="6">Sun</option>
                </select>
              </div>
              <div style="min-width:220px;display:none;" id="cron-dom-wrap">
                <label style="display:block;color:var(--muted-2);font-size:0.85rem;margin-bottom:0.25rem;">Day of month</label>
                <input id="cron-day-of-month" class="host-search" type="number" min="1" max="31" placeholder="12" />
              </div>
              <div style="min-width:220px;display:none;" id="cron-time-wrap">
                <label style="display:block;color:var(--muted-2);font-size:0.85rem;margin-bottom:0.25rem;">Time</label>
                <input id="cron-time" class="host-search" type="time" />
              </div>

              <div style="min-width:220px;">
                <label style="display:block;color:var(--muted-2);font-size:0.85rem;margin-bottom:0.25rem;">Action</label>
                <select id="cron-action" class="host-search">
                  <option value="dist-upgrade" selected>dist-upgrade</option>
                  <option value="inventory-now">inventory-now</option>
                  <option value="security-campaign">security campaign</option>
                </select>
              </div>
              <button class="btn" id="cron-hosts-open" type="button">Choose hosts…</button>
              <button class="btn btn-primary" id="cron-create" type="button">Create (selected hosts)</button>
              <span id="cron-create-status" style="color:var(--muted-2);font-size:0.9rem;"></span>
            </div>
          </div>
        </div>

        

        <div class="admin-card" id="cron-hosts-panel" style="display:none;margin-bottom:1rem;">
          <div class="admin-card-title" style="display:flex;align-items:center;justify-content:space-between;gap:1rem;flex-wrap:wrap;">
            <span>Select hosts for this cronjob</span>
            <div style="display:flex;gap:0.5rem;flex-wrap:wrap;align-items:center;">
              <button class="btn" id="cron-hosts-select-all" type="button">Select all</button>
              <button class="btn" id="cron-hosts-select-none" type="button">Select none</button>
              <button class="btn" id="cron-hosts-close" type="button">Hide</button>
            </div>
          </div>
          <div class="admin-card-body">
            <div class="admin-note" style="margin-top:-0.25rem;">This selection is only for cronjobs (independent of the Hosts tab checkboxes).</div>
            <div class="input-with-clear" style="max-width:520px;">
              <input id="cron-hosts-search" class="host-search" type="text" placeholder="Filter hosts (name, id, IP)…" />
              <button class="clear-btn" id="cron-hosts-search-clear" type="button" aria-label="Clear filter">×</button>
            </div>
            <div id="cron-hosts-list" style="margin-top:0.75rem;max-height:320px;overflow:auto;border:1px solid var(--border);border-radius:10px;background:var(--panel-2);padding:0.5rem;"></div>
            <div style="margin-top:0.5rem;color:var(--muted-2);font-size:0.9rem;">Selected: <span id="cron-hosts-count">0</span></div>
          </div>
        </div>
<div class="admin-card">
          <div class="admin-card-title" style="display:flex;align-items:center;justify-content:space-between;gap:1rem;flex-wrap:wrap;">
            <span>My cronjobs</span>
            <button class="btn" id="cron-refresh" type="button">Reload</button>
          </div>
          <div class="admin-card-body">
            <div style="overflow-x:auto;">
              <table class="process-table" style="min-width:900px;">
                <thead>
                  <tr>
                    <th>Run at</th>
                    <th>Name</th>
                    <th>Action</th>
                    <th>Targets</th>
                    <th>Status</th>
                    <th></th>
                  </tr>
                </thead>
                <tbody id="cronjobs-table">
                  <tr><td colspan="6" style="text-align:center;color:#a0aec0;">Loading…</td></tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="tab-content-custom" id="sshkeys-tab">
      <div class="admin-content">
        <div class="section-title">SSH Keys</div>
        <div class="admin-note" style="margin-bottom:0.75rem;">Upload your public key and request deployment to hosts. An admin must approve. Keys are installed into <code>authorized_keys</code> and a restricted NOPASSWD sudo profile is applied (variant B).</div>

        <div class="admin-card" style="margin-bottom:1rem;">
          <div class="admin-card-title">Add public key</div>
          <div class="admin-card-body">
            <div style="display:flex;gap:0.75rem;flex-wrap:wrap;align-items:flex-end;">
              <div style="min-width:220px;flex:1;">
                <label style="display:block;color:var(--muted-2);font-size:0.85rem;margin-bottom:0.25rem;">Name (optional)</label>
                <input id="sshkey-name" class="host-search" type="text" placeholder="e.g. laptop" />
              </div>
              <div style="min-width:520px;flex:3;">
                <label style="display:block;color:var(--muted-2);font-size:0.85rem;margin-bottom:0.25rem;">Public key</label>
                <input id="sshkey-pub" class="host-search" type="text" placeholder="ssh-ed25519 AAAA... comment" />
              </div>
              <button class="btn btn-primary" id="sshkey-add" type="button">Add</button>
              <span id="sshkey-add-status" style="color:var(--muted-2);font-size:0.9rem;"></span>
            </div>
          </div>
        </div>

        <div class="admin-card" style="margin-bottom:1rem;">
          <div class="admin-card-title" style="display:flex;align-items:center;justify-content:space-between;gap:1rem;flex-wrap:wrap;">
            <span id="sshkeys-list-title">My keys</span>
            <button class="btn" id="sshkey-refresh" type="button">Reload</button>
          </div>
          <div class="admin-card-body">
            <div style="overflow-x:auto;">
              <table class="process-table" style="min-width:900px;">
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Fingerprint</th>
                    <th>Public key</th>
                    <th></th>
                  </tr>
                </thead>
                <tbody id="sshkeys-table">
                  <tr><td colspan="4" style="text-align:center;color:#a0aec0;">Loading…</td></tr>
                </tbody>
              </table>
            </div>

            <div style="margin-top:0.75rem;display:flex;gap:0.5rem;align-items:center;flex-wrap:wrap;">
              <button class="btn" id="sshkey-hosts-open" type="button">Choose hosts…</button>
              <button class="btn btn-primary" id="sshkey-request-deploy" type="button">Request deploy (selected key + selected hosts)</button>
              <span id="sshkey-request-status" style="color:var(--muted-2);font-size:0.9rem;"></span>
            </div>

            <div class="admin-card" id="sshkey-hosts-panel" style="display:none;margin-top:0.75rem;">
              <div class="admin-card-title" style="display:flex;align-items:center;justify-content:space-between;gap:1rem;flex-wrap:wrap;">
                <span>Select hosts</span>
                <div style="display:flex;gap:0.5rem;flex-wrap:wrap;align-items:center;">
                  <button class="btn" id="sshkey-hosts-select-all" type="button">Select all</button>
                  <button class="btn" id="sshkey-hosts-select-none" type="button">Select none</button>
                  <button class="btn" id="sshkey-hosts-close" type="button">Hide</button>
                </div>
              </div>
              <div class="admin-card-body">
                <div class="input-with-clear" style="max-width:520px;">
                  <input id="sshkey-hosts-search" class="host-search" type="text" placeholder="Filter hosts (name, id, IP, OS)…" />
                  <button class="clear-btn" id="sshkey-hosts-search-clear" type="button" aria-label="Clear filter">×</button>
                </div>
                <div id="sshkey-hosts-list" style="margin-top:0.75rem;max-height:320px;overflow:auto;border:1px solid var(--border);border-radius:10px;background:var(--panel-2);padding:0.5rem;"></div>
                <div style="margin-top:0.5rem;color:var(--muted-2);font-size:0.9rem;">Selected: <span id="sshkey-hosts-count">0</span></div>
              </div>
            </div>

          </div>
        </div>

        <div class="admin-card">
          <div class="admin-card-title">My deployment requests</div>
          <div class="admin-card-body">
            <div style="overflow-x:auto;">
              <table class="process-table" style="min-width:900px;">
                <thead>
                  <tr>
                    <th>Created</th>
                    <th>Key</th>
                    <th>Targets</th>
                    <th>Status</th>
                    <th>Approved by</th>
                    <th>Error</th>
                  </tr>
                </thead>
                <tbody id="sshkey-requests-table">
                  <tr><td colspan="6" style="text-align:center;color:#a0aec0;">Loading…</td></tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>

        <div class="admin-card" id="sshkey-admin-keys" style="margin-top:1rem;display:none;">
          <div class="admin-card-title" style="display:flex;align-items:center;justify-content:space-between;gap:1rem;flex-wrap:wrap;">
            <span>Admin: all users’ SSH keys</span>
            <button class="btn" id="sshkey-admin-keys-refresh" type="button">Reload</button>
          </div>
          <div class="admin-card-body">
            <div style="overflow-x:auto;">
              <table class="process-table" style="min-width:900px;">
                <thead>
                  <tr>
                    <th>Created</th>
                    <th>User</th>
                    <th>Name</th>
                    <th>Fingerprint</th>
                    <th>Public key</th>
                  </tr>
                </thead>
                <tbody id="sshkey-admin-keys-table">
                  <tr><td colspan="5" style="text-align:center;color:#a0aec0;">Loading…</td></tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>

        <div class="admin-card" id="sshkey-admin-approvals" style="margin-top:1rem;display:none;">
          <div class="admin-card-title" style="display:flex;align-items:center;justify-content:space-between;gap:1rem;flex-wrap:wrap;">
            <span>Admin: pending deployment approvals</span>
            <button class="btn" id="sshkey-admin-refresh" type="button">Reload</button>
          </div>
          <div class="admin-card-body">
            <div style="overflow-x:auto;">
              <table class="process-table" style="min-width:900px;">
                <thead>
                  <tr>
                    <th>Created</th>
                    <th>User</th>
                    <th>Key</th>
                    <th>Targets</th>
                    <th></th>
                  </tr>
                </thead>
                <tbody id="sshkey-admin-table">
                  <tr><td colspan="5" style="text-align:center;color:#a0aec0;">Loading…</td></tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>

      </div>
    </div>
    <div class="tab-content-custom" id="terminal-tab">
      <div class="terminal-container">
        <div id="terminal"></div>
      </div>
    </div>

    <div class="tab-content-custom" id="users-tab">
      <div class="users-content">
        <div class="section-title">System Users & Sudo Rights</div>
        <div class="admin-note" id="users-access-note" style="display:none;">Admin access required to lock or unlock
          users.</div>
        <div id="users-list">
          <div class="loading">Select a host to view users...</div>
        </div>
      </div>
    </div>

    <div class="tab-content-custom" id="admin-tab">
      <div class="admin-content">
        <div class="section-title">Admin</div>
        <div class="admin-panels" style="display:grid;grid-template-columns:1fr 1.2fr;gap:1rem;align-items:start;">
          <div>
            <div class="admin-card">
              <div class="admin-card-title">Create user</div>
              <div class="admin-card-body">
                <input id="register-username" class="admin-input" type="text" placeholder="New username" />
                <input id="register-password" class="admin-input" type="password" placeholder="Temporary password" />
                <button class="btn btn-primary" id="register-user-btn">Create user</button>
                <div class="admin-status" id="register-status"></div>
              </div>
            </div>

            <div class="admin-card" style="margin-top:1rem;">
              <div class="admin-card-title">Reset password</div>
              <div class="admin-card-body">
                <input id="reset-username" class="admin-input" type="text" placeholder="Username to reset" />
                <input id="reset-password" class="admin-input" type="password" placeholder="New password" />
                <button class="btn btn-primary" id="reset-password-btn">Reset password</button>
                <div class="admin-status" id="reset-status"></div>
              </div>
            </div>

            <div class="admin-card" id="admin-access-note" style="margin-top:1rem;">
              <div class="admin-card-title">Access</div>
              <div class="admin-card-body">
                <div class="admin-note">Admin access required to manage app users.</div>
              </div>
            </div>
          </div>

          <div>
            <div class="admin-card" id="admin-users-card">
              <div class="admin-card-title" style="display:flex;align-items:center;justify-content:space-between;gap:1rem;flex-wrap:wrap;">
                <span>Users</span>
                <button class="btn" id="admin-users-refresh" type="button">Reload</button>
              </div>
              <div class="admin-card-body">
                <div style="overflow-x:auto;">
                  <table class="process-table" style="min-width:720px;">
                    <thead>
                      <tr>
                        <th>Username</th>
                        <th>Role</th>
                        <th>Active</th>
                        <th>MFA</th>
                        <th>Created</th>
                        <th></th>
                      </tr>
                    </thead>
                    <tbody id="admin-users-table">
                      <tr><td colspan="6" style="text-align:center;color:#a0aec0;">Loading…</td></tr>
                    </tbody>
                  </table>
                </div>
                <div class="admin-status" id="admin-users-status"></div>
              </div>
            </div>

            <div class="admin-card" id="admin-audit-card" style="margin-top:1rem;">
              <div class="admin-card-title" style="display:flex;align-items:center;justify-content:space-between;gap:1rem;flex-wrap:wrap;">
                <span>Audit log</span>
                <div style="display:flex;gap:0.5rem;flex-wrap:wrap;align-items:center;">
                  <input id="audit-filter-action" class="host-search" style="max-width:220px;" type="text" placeholder="Action (e.g. auth.login)" />
                  <input id="audit-filter-actor" class="host-search" style="max-width:200px;" type="text" placeholder="Actor (username)" />
                  <button class="btn" id="admin-audit-refresh" type="button">Reload</button>
                </div>
              </div>
              <div class="admin-card-body">
                <div style="overflow-x:auto;">
                  <table class="process-table" style="min-width:900px;">
                    <thead>
                      <tr>
                        <th>Time</th>
                        <th>Action</th>
                        <th>Actor</th>
                        <th>Target</th>
                        <th>IP</th>
                        <th>Meta</th>
                      </tr>
                    </thead>
                    <tbody id="admin-audit-table">
                      <tr><td colspan="6" style="text-align:center;color:#a0aec0;">Loading…</td></tr>
                    </tbody>
                  </table>
                </div>
                <div class="admin-status" id="admin-audit-status"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div class="tab-content-custom" id="services-tab">
      <div class="services-content">
        <div class="section-title">System Services</div>
        <div id="services-list">
          <div class="loading">Select a host to view services...</div>
        </div>
      </div>
    </div>

    <div class="tab-content-custom" id="packages-tab">
      <div class="packages-content">
        <div class="section-title">Installed Packages</div>
        <div style="display:flex;gap:1rem;flex-wrap:wrap;align-items:center;margin-bottom:0.75rem;">
          <div class="input-with-clear">
            <input id="packages-search" class="host-search" type="text"
              placeholder="Search installed packages (name/version)..." />
            <button class="clear-btn" id="packages-search-clear" type="button" aria-label="Clear search">×</button>
          </div>
          <button class="btn btn-primary" id="packages-check-updates">Check updates</button>
          <label class="vuln-inline" style="margin:0;">
            <input type="checkbox" id="packages-updates-only" />
            Updates only
          </label>
          <div id="packages-meta" style="font-size:0.85rem;color:var(--muted-2);"></div>
        </div>
        <div style="display:flex;gap:1rem;flex-wrap:wrap;align-items:center;margin-bottom:1rem;">
          <label class="vuln-inline" style="margin:0;">
            <input type="checkbox" id="select-visible-packages" />
            Select all visible packages
          </label>
          <label class="vuln-inline" style="margin:0;">
            <input type="checkbox" id="pkg-interactive-terminal" />
            Interactive (Terminal)
          </label>
          <button class="btn btn-primary" id="pkg-upgrade-selected" disabled>Upgrade selected</button>
          <button class="btn btn-warning" id="pkg-reinstall-selected" disabled>Reinstall selected</button>
          <button class="btn btn-danger" id="pkg-remove-selected" disabled>Remove selected</button>
          <div id="pkg-actions-status" style="font-size:0.85rem;color:var(--muted-2);"></div>
        </div>
        <div class="packages-split">
          <div id="packages-list">
            <div class="loading">Select a host to view packages...</div>
          </div>
          <div id="package-info" class="package-info-panel"></div>
        </div>
      </div>
    </div>
  </div>
  </div>

  <div class="modal-overlay" id="ansible-modal" aria-hidden="true" hidden>
    <div class="modal-panel" role="dialog" aria-modal="true" aria-labelledby="ansible-modal-title">
      <div class="modal-header">
        <div class="modal-title" id="ansible-modal-title">Run Ansible playbook</div>
        <button class="btn modal-close" id="ansible-modal-close" type="button">Close</button>
      </div>
      <div class="modal-body">
        <div class="modal-meta" id="ansible-modal-meta"></div>
        <div class="modal-form" id="ansible-modal-form"></div>
        <div class="modal-actions">
          <button class="btn btn-primary" id="ansible-modal-run" type="button">Run</button>
        </div>
        <div class="modal-status" id="ansible-modal-status"></div>
        <div class="modal-meta" id="ansible-modal-log"></div>
        <pre class="modal-output" id="ansible-modal-output"></pre>
        <div class="modal-actions" style="margin-top:12px;justify-content:space-between;">
          <div class="modal-meta" id="ansible-logs-status"></div>
          <button class="btn" id="ansible-logs-refresh" type="button">View logs</button>
        </div>
        <div class="modal-meta" id="ansible-logs-list"></div>
        <div class="modal-actions" style="margin-top:12px;justify-content:flex-end;">
          <button class="btn" id="ansible-output-copy" type="button">Copy output</button>
        </div>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="user-modal" aria-hidden="true" hidden>
    <div class="modal-panel" role="dialog" aria-modal="true" aria-labelledby="user-modal-title" style="width:min(1000px,96vw);max-width:96vw;max-height:92vh;display:flex;flex-direction:column;">
      <div class="modal-header">
        <div class="modal-title" id="user-modal-title">User details</div>
        <button class="btn modal-close" id="user-modal-close" type="button">Close</button>
      </div>
      <div class="modal-body" style="flex:1;min-height:0;overflow:auto;">
        <div class="modal-meta" id="user-modal-meta"></div>
        <div class="modal-output" id="user-modal-output" style="white-space:normal;"></div>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="service-modal" aria-hidden="true" hidden>
    <div class="modal-panel" role="dialog" aria-modal="true" aria-labelledby="service-modal-title" style="width:min(1000px,96vw);max-width:96vw;max-height:92vh;display:flex;flex-direction:column;">
      <div class="modal-header">
        <div class="modal-title" id="service-modal-title">Service details</div>
        <button class="btn modal-close" id="service-modal-close" type="button">Close</button>
      </div>
      <div class="modal-body" style="flex:1;min-height:0;overflow:auto;">
        <div class="modal-meta" id="service-modal-meta"></div>
        <div class="modal-output" id="service-modal-output" style="white-space:normal;"></div>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="disk-modal" aria-hidden="true" hidden>
    <div class="modal-panel" role="dialog" aria-modal="true" aria-labelledby="disk-modal-title" style="width:min(1400px,98vw);max-width:98vw;max-height:96vh;display:flex;flex-direction:column;">
      <div class="modal-header">
        <div class="modal-title" id="disk-modal-title">Disk usage (df -h)</div>
        <button class="btn modal-close" id="disk-modal-close" type="button">Close</button>
      </div>
      <div class="modal-body" style="flex:1;min-height:0;overflow:auto;">
        <div class="modal-meta" id="disk-modal-meta"></div>
        <div class="modal-actions" style="margin:8px 0;justify-content:space-between;position:sticky;top:0;background:var(--panel-2, transparent);padding:6px 0;z-index:2;gap:12px;flex-wrap:wrap;">
          <label style="display:flex;align-items:center;gap:8px;color:var(--muted-2);font-size:0.9rem;user-select:none;">
            <input type="checkbox" id="disk-modal-show-virtual" />
            Show virtual filesystems (tmpfs/overlay/squashfs)
          </label>
          <button class="btn" id="disk-modal-refresh" type="button">Refresh</button>
        </div>
        <div class="modal-output" id="disk-modal-output" style="white-space:normal;"></div>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="sshkey-approval-modal" aria-hidden="true" hidden>
    <div class="modal-panel" role="dialog" aria-modal="true" aria-labelledby="sshkey-approval-modal-title">
      <div class="modal-header">
        <div class="modal-title" id="sshkey-approval-modal-title">Deployment approval details</div>
        <button class="btn modal-close" id="sshkey-approval-modal-close" type="button">Close</button>
      </div>
      <div class="modal-body">
        <div class="modal-meta" id="sshkey-approval-modal-meta"></div>
        <div class="modal-actions" style="margin:8px 0;justify-content:flex-end;">
          <a class="btn" id="sshkey-approval-modal-download-stdout" href="#" download style="display:none;">Download stdout</a>
          <a class="btn" id="sshkey-approval-modal-download-stderr" href="#" download style="display:none;">Download stderr</a>
          <a class="btn" id="sshkey-approval-modal-download-zip" href="#" download style="display:none;">Download logs.zip</a>
        </div>
        <pre class="modal-output" id="sshkey-approval-modal-targets" style="white-space:pre-wrap;"></pre>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="mfa-modal" aria-hidden="true" hidden>
    <div class="modal-panel" role="dialog" aria-modal="true" aria-labelledby="mfa-modal-title" style="width:min(720px,96vw);max-width:96vw;">
      <div class="modal-header">
        <div class="modal-title" id="mfa-modal-title">MFA</div>
        <!-- No close button: MFA is required for privileged roles -->
      </div>
      <div class="modal-body">
        <div class="modal-meta" id="mfa-modal-status" style="color:var(--muted-2);"></div>
        <div id="mfa-modal-body"></div>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="audit-detail-modal" aria-hidden="true" hidden>
    <div class="modal-panel" role="dialog" aria-modal="true" aria-labelledby="audit-detail-modal-title" style="width:min(1100px,96vw);max-width:96vw;max-height:92vh;display:flex;flex-direction:column;">
      <div class="modal-header">
        <div class="modal-title" id="audit-detail-modal-title">Audit event</div>
        <button class="btn modal-close" id="audit-detail-modal-close" type="button">Close</button>
      </div>
      <div class="modal-body" style="flex:1;min-height:0;overflow:auto;">
        <div class="modal-meta" id="audit-detail-modal-meta"></div>
        <textarea id="audit-detail-modal-output" readonly style="width:100%;min-height:420px;resize:vertical;padding:10px;border:1px solid var(--border);border-radius:10px;background:var(--panel-2);color:var(--text);font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;user-select:text;"></textarea>
        <div class="modal-actions" style="margin-top:12px;justify-content:flex-end;gap:8px;">
          <button class="btn" id="audit-detail-modal-copy" type="button">Copy</button>
        </div>
      </div>
    </div>
  </div>

  <div id="toast-container" class="toast-container" aria-live="polite" aria-atomic="true"></div>

  <script>
    // Init xterm only when the container exists. If this throws early, it can break other UI JS (e.g. theme toggle).
    let term = null;
    function initTerminalOnce() {
      if (term) return;
      const termEl = document.getElementById('terminal');
      if (!termEl) return;
      term = new Terminal({
        convertEol: true,
        theme: {
          background: '#1e1e1e',
          foreground: '#d4d4d4',
          cursor: '#aeafad',
          selection: '#264f78',
          black: '#000000',
          red: '#cd3131',
          green: '#0dbc79',
          yellow: '#e5e510',
          blue: '#2472c8',
          magenta: '#bc3fbc',
          cyan: '#11a8cd',
          white: '#e5e5e5',
          brightBlack: '#666666',
          brightRed: '#f14c4c',
          brightGreen: '#23d18b',
          brightYellow: '#f5f543',
          brightBlue: '#3b8eea',
          brightMagenta: '#d670d6',
          brightCyan: '#29b8db',
          brightWhite: '#e5e5e5'
        }
      });
      term.open(termEl);
      // Ensure keystrokes go to xterm immediately (otherwise onData won't fire until focused).
      try { term.focus(); } catch { }
      termEl.addEventListener('mousedown', () => { try { term.focus(); } catch { } });
      termEl.addEventListener('touchstart', () => { try { term.focus(); } catch { } }, { passive: true });
    }

    let ws = null;
    let currentAgentId = null;
    let currentUsername = null;
    let adminUsername = null;
    let currentPermissions = {};

    // Global fetch wrapper:
    // - always send cookies (credentials: 'include')
    // - add CSRF header for state-changing requests
    (function(){
      function getCookie(name) {
        const v = `; ${document.cookie}`;
        const parts = v.split(`; ${name}=`);
        if (parts.length === 2) return parts.pop().split(';').shift();
        return '';
      }

      const origFetch = window.fetch ? window.fetch.bind(window) : null;
      if (!origFetch) return;

      window.fetch = function(input, init) {
        const opts = init ? { ...init } : {};
        const method = String(opts.method || 'GET').toUpperCase();
        const headers = new Headers(opts.headers || {});

        if (!('credentials' in opts)) opts.credentials = 'include';

        if (method !== 'GET' && method !== 'HEAD' && method !== 'OPTIONS') {
          const csrf = getCookie('fleet_csrf');
          if (csrf && !headers.has('X-CSRF-Token')) headers.set('X-CSRF-Token', csrf);
        }

        opts.headers = headers;
        return origFetch(input, opts);
      };
    })();

    function getTheme() {
      return document.documentElement.dataset.theme || 'dark';
    }

    function setTheme(theme) {
      document.documentElement.dataset.theme = theme;
      try { localStorage.setItem('fleet_theme', theme); } catch { }
    }

    function toggleTheme() {
      const next = getTheme() === 'dark' ? 'light' : 'dark';
      setTheme(next);
    }

    function initThemeToggle() {
      const btn = document.getElementById('theme-toggle');
      if (!btn) return;
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        toggleTheme();
      });
    }

    // Attach terminal input handler ONCE.
    // If we attach this inside connect(), it will stack and each keystroke gets sent multiple times.
    let terminalInputHandlerAttached = false;
    function attachTerminalInputHandlerOnce() {
      if (!term || terminalInputHandlerAttached) return;
      terminalInputHandlerAttached = true;
      term.onData(data => {
        if (ws && ws.readyState === 1) {
          ws.send(new TextEncoder().encode(data));
        }
      });
    }

    function setAdminStatus(message, state) {
      const statusEl = document.getElementById('register-status');
      if (!statusEl) return;
      statusEl.textContent = message || '';
      statusEl.classList.remove('error', 'success');
      if (state === 'error') statusEl.classList.add('error');
      if (state === 'success') statusEl.classList.add('success');
    }

    function setResetStatus(message, state) {
      const statusEl = document.getElementById('reset-status');
      if (!statusEl) return;
      statusEl.textContent = message || '';
      statusEl.classList.remove('error', 'success');
      if (state === 'error') statusEl.classList.add('error');
      if (state === 'success') statusEl.classList.add('success');
    }

    function showToast(message, type = 'info', timeoutMs = 3500) {
      const container = document.getElementById('toast-container');
      if (!container) return;
      const toast = document.createElement('div');
      toast.className = `toast toast-${type}`;
      toast.textContent = message;
      container.appendChild(toast);
      requestAnimationFrame(() => toast.classList.add('show'));
      const remove = () => {
        toast.classList.remove('show');
        setTimeout(() => toast.remove(), 200);
      };
      setTimeout(remove, timeoutMs);
    }

    function updateSshKeysLabels() {
      const titleEl = document.getElementById('sshkeys-list-title');
      if (!titleEl) return;
      const isAdmin = (currentPermissions && String(currentPermissions.role||'').toLowerCase() === 'admin') || !!currentPermissions.can_manage_users;
      titleEl.textContent = isAdmin ? 'SSH Keys' : 'My keys';
    }

    async function loadAuthInfo() {
      const userEl = document.getElementById('current-user');
      const logoutBtn = document.getElementById('logout-btn');
      const adminMenuItem = document.getElementById('admin-menu-item');
      const adminNote = document.getElementById('admin-access-note');
      const adminTab = document.getElementById('admin-tab');
      if (!userEl) return;

      let meUser = null;
      let mePermissions = {};
      try {
        const resp = await fetch('/auth/me');
        if (resp.ok) {
          const data = await resp.json();
          meUser = data.username || null;
          mePermissions = data.permissions || {};
          window.__mfa = data.mfa || null;
        }
      } catch { }

      userEl.textContent = meUser ? `Signed in as ${meUser}` : 'Signed in';

      let admin = null;
      try {
        const resp = await fetch('/auth/admin-info');
        if (resp.ok) {
          const data = await resp.json();
          admin = data.admin_username || null;
        }
      } catch { }

      currentUsername = meUser;
      currentPermissions = mePermissions || {};
      adminUsername = admin;
      const isAdmin = (currentPermissions && String(currentPermissions.role||'').toLowerCase() === 'admin') || !!currentPermissions.can_manage_users || !!(meUser && admin && meUser === admin);

      // Forced MFA flow (for admin/operator).
      try {
        const mfa = window.__mfa || null;
        if (mfa && mfa.setup_required) {
          // Start enrollment (QR) and force modal open.
          await mfaEnrollStart();
        } else if (mfa && mfa.verify_required) {
          openMfaModal('verify');
        }
      } catch {}
      if (adminMenuItem) {
        adminMenuItem.style.display = isAdmin ? 'flex' : 'none';
      }
      if (adminNote) {
        adminNote.style.display = isAdmin ? 'none' : 'block';
      }
      if (adminTab) {
        adminTab.querySelectorAll('input, button').forEach(el => {
          if (el.id === 'admin-menu-item' || el.id === 'settings-btn') return;
          el.disabled = !isAdmin;
        });
      }
      if (logoutBtn) {
        logoutBtn.style.display = meUser ? 'flex' : 'none';
      }

      const usersAccessNote = document.getElementById('users-access-note');
      if (usersAccessNote) {
        usersAccessNote.style.display = currentPermissions.can_lock_users ? 'none' : 'block';
      }

      updateSshKeysLabels();
    }

    // Tab switching removed - tabs are now accessed via server info buttons only

    let loadGraphChart = null;
    let loadGraphData = [];
    const metricsLifecycleState = createUiStateAccess('hostMetricsLifecycle', {
      metricsUpdateInterval: null,
      topProcessesUpdateInterval: null,
      topProcessesInFlight: false,
      currentMetricsAgentId: null,
    });
    if (typeof window.initMetricsLifecycleState === 'function') {
      window.initMetricsLifecycleState(metricsLifecycleState);
    }
    const stopMetricsPolling = window.stopMetricsPollingLifecycle || function (stateAccess) {
      if (!stateAccess || typeof stateAccess.get !== 'function' || typeof stateAccess.set !== 'function') return;
      const metricsTimer = stateAccess.get('metricsUpdateInterval');
      const topTimer = stateAccess.get('topProcessesUpdateInterval');
      if (metricsTimer) { clearInterval(metricsTimer); stateAccess.set('metricsUpdateInterval', null); }
      if (topTimer) { clearInterval(topTimer); stateAccess.set('topProcessesUpdateInterval', null); }
    };
    let loadTimeframeSeconds = 3600;
    const METRICS_POLL_MS = 60_000; // 1 minute is enough for disk/mem/ips/top-procs/loadavg
    const TOP_PROCS_POLL_MS = 1_000; // top processes can change quickly

    function initLoadTimeframeControls() {
      const sel = document.getElementById('load-timeframe');
      if (!sel) return;
      sel.addEventListener('change', async () => {
        const v = parseInt(sel.value, 10);
        if (!isNaN(v)) loadTimeframeSeconds = v;
        if (metricsLifecycleState.get('currentMetricsAgentId')) {
          loadGraphData = [];
          await loadHistoricalLoadData(metricsLifecycleState.get('currentMetricsAgentId'));
        }
      });
      // Ensure it matches initial value
      const v = parseInt(sel.value, 10);
      if (!isNaN(v)) loadTimeframeSeconds = v;
    }

    // Hosts + filtering state
    const hostFilterSelectionState = createUiStateAccess('hostFilterSelection', {
      allHosts: [],
      hostSearchQuery: '',
      labelEnvFilter: '',
      labelRoleFilter: '',
      vulnFilteredAgentIds: null,
      selectedAgentIds: new Set(),
      lastRenderedAgentIds: [],
    });
    const hostFilterSelectionDefaults = (typeof window.initHostFilterSelectionState === 'function')
      ? window.initHostFilterSelectionState(hostFilterSelectionState)
      : {
        allHosts: [],
        hostSearchQuery: '',
        labelEnvFilter: '',
        labelRoleFilter: '',
        vulnFilteredAgentIds: null,
        selectedAgentIds: new Set(),
        lastRenderedAgentIds: [],
      };
    let allHosts = hostFilterSelectionDefaults.allHosts;
    let hostSearchQuery = hostFilterSelectionDefaults.hostSearchQuery;
    let labelEnvFilter = hostFilterSelectionDefaults.labelEnvFilter;
    let labelRoleFilter = hostFilterSelectionDefaults.labelRoleFilter;
    let vulnFilteredAgentIds = hostFilterSelectionDefaults.vulnFilteredAgentIds; // Set<string> or null
    let selectedAgentIds = hostFilterSelectionDefaults.selectedAgentIds;
    let lastRenderedAgentIds = hostFilterSelectionDefaults.lastRenderedAgentIds; // string[]

    function syncHostFilterSelectionState(key, value) {
      hostFilterSelectionState.set(key, value);
      return value;
    }
    // Will be initialized in initHostFilters(); renderHosts() calls this.
    let updateUpgradeControlsFn = () => { };
    let lastPkgVerification = null; // { packageName, vulnVersion, resultsByAgentId: { [aid]: { ok, found, version, status } } }
    let lastCveCheck = null; // { cve, resultsByAgentId: { [aid]: { affected, packages?: string[] } } }
    let lastCveAffectedAgentIds = []; // string[] for last CVE run (online hosts only)
    let lastCveUnionPackages = []; // string[] union of affected packages across affected hosts
    let selectedCvePackages = new Set(); // Set<string> selected in CVE package list
    let ansiblePlaybooks = [];

    function rebuildLabelFilterOptions(hosts) {
      const envSel = document.getElementById('label-env');
      const roleSel = document.getElementById('label-role');
      if (!envSel || !roleSel) return;

      const envVals = new Set();
      const roleVals = new Set();
      (hosts || []).forEach(h => {
        const env = (hostLabel(h, 'env') || '').trim();
        const role = (hostLabel(h, 'role') || '').trim();
        if (env) envVals.add(env);
        if (role) roleVals.add(role);
      });

      const envList = Array.from(envVals).sort((a, b) => a.localeCompare(b));
      const roleList = Array.from(roleVals).sort((a, b) => a.localeCompare(b));

      const prevEnv = envSel.value || '';
      const prevRole = roleSel.value || '';

      envSel.innerHTML = `<option value="">Env: Any</option>` + envList.map(v => `<option value="${escapeHtml(v)}">${escapeHtml(v)}</option>`).join('');
      roleSel.innerHTML = `<option value="">Role: Any</option>` + roleList.map(v => `<option value="${escapeHtml(v)}">${escapeHtml(v)}</option>`).join('');

      // Restore selections if still valid
      if (prevEnv && envList.includes(prevEnv)) envSel.value = prevEnv;
      else envSel.value = '';
      if (prevRole && roleList.includes(prevRole)) roleSel.value = prevRole;
      else roleSel.value = '';

      labelEnvFilter = syncHostFilterSelectionState('labelEnvFilter', envSel.value || '');
      labelRoleFilter = syncHostFilterSelectionState('labelRoleFilter', roleSel.value || '');
    }

    function applyHostFilters() {
      const q = normalize(hostSearchQuery).trim();
      let filtered = allHosts.slice();

      if (vulnFilteredAgentIds) {
        filtered = filtered.filter(h => vulnFilteredAgentIds.has(h.agent_id));
      }

      if (labelEnvFilter) {
        filtered = filtered.filter(h => (hostLabel(h, 'env') || '') === labelEnvFilter);
      }
      if (labelRoleFilter) {
        filtered = filtered.filter(h => (hostLabel(h, 'role') || '') === labelRoleFilter);
      }

      if (q) {
        filtered = filtered.filter(h => {
          const hay = `${h.hostname || ''} ${h.agent_id || ''} ${h.ip_address || ''} ${h.fqdn || ''} ${h.os_id || ''} ${h.os_version || ''}`.toLowerCase();
          return hay.includes(q);
        });
      }

      renderHosts(filtered);
    }

    function renderHosts(hosts) {
      const hostsDiv = document.getElementById('hosts');
      hostsDiv.innerHTML = '';
      lastRenderedAgentIds = syncHostFilterSelectionState('lastRenderedAgentIds', (hosts || []).map(h => h.agent_id));

      if (!hosts || hosts.length === 0) {
        hostsDiv.innerHTML = '<div class="empty-state">No hosts match your filters</div>';
        updateUpgradeControlsFn();
        return;
      }

      hosts.forEach(host => {
        const div = document.createElement('div');
        div.className = 'host-item';
        div.dataset.agentId = host.agent_id;
        div.onclick = () => { selectHost(host.agent_id, host.hostname); };

        let pkgLine = '';
        const pkgNameInput = (document.getElementById('vuln-package')?.value || '').trim();
        const vulnVersionInput = (document.getElementById('vuln-version')?.value || '').trim();
        if (pkgNameInput && lastPkgVerification && lastPkgVerification.packageName === pkgNameInput) {
          const r = (lastPkgVerification.resultsByAgentId || {})[host.agent_id];
          if (r) {
            const v = r.version ? `<code>${escapeHtml(r.version)}</code>` : '<code>n/a</code>';
            if (r.status === 'upgraded') {
              pkgLine = `<div class="pkg-status-line"><span class="pkg-badge good">Upgraded</span> ${v}</div>`;
            } else if (r.status === 'vulnerable') {
              const vv = vulnVersionInput ? `<code>${escapeHtml(vulnVersionInput)}</code>` : '';
              pkgLine = `<div class="pkg-status-line"><span class="pkg-badge bad">Still vulnerable</span> ${v} ${vv ? `<span style="color:#a0aec0;">(vuln = ${vv})</span>` : ''}</div>`;
            } else if (r.status === 'installed') {
              pkgLine = `<div class="pkg-status-line"><span class="pkg-badge neutral">Installed</span> ${v}</div>`;
            } else if (r.status === 'not-installed') {
              pkgLine = `<div class="pkg-status-line"><span class="pkg-badge neutral">Not installed</span></div>`;
            } else {
              pkgLine = `<div class="pkg-status-line"><span class="pkg-badge neutral">Unknown</span></div>`;
            }
          }
        }

        const isOnline = !!host.is_online;
        const lastSeen = host.last_seen ? new Date(host.last_seen) : null;
        const lastSeenText = lastSeen ? formatRelativeTime(lastSeen) : 'never';
        const ip = host.ip_address || '';
        const fqdn = host.fqdn || '';
        const env = hostLabel(host, 'env') || '';
        const role = hostLabel(host, 'role') || '';

        div.innerHTML = `
          <div class="host-select-wrap">
            <input class="host-select" type="checkbox" data-agent-id="${host.agent_id}" ${selectedAgentIds.has(host.agent_id) ? 'checked' : ''} />
          </div>
          <div class="host-meta">
            <div class="host-row-top">
              <div class="host-name">${escapeHtml(host.hostname || host.agent_id)}</div>
              <span class="status-dot ${isOnline ? 'online' : 'offline'}" title="${isOnline ? 'online' : 'offline'}"></span>
            </div>
            <div class="host-subline">
              <span class="host-subitem">${ip ? escapeHtml(ip) : (fqdn ? escapeHtml(fqdn) : '')}</span>
              <span class="host-subsep">•</span>
              <span class="host-subitem">seen ${escapeHtml(lastSeenText)}</span>
            </div>
            <div class="host-tags">
              ${env ? `<span class="tag">env: <code>${escapeHtml(env)}</code></span>` : ''}
              ${role ? `<span class="tag">role: <code>${escapeHtml(role)}</code></span>` : ''}
            </div>
            ${pkgLine}
          </div>
        `;
        hostsDiv.appendChild(div);

        // Checkbox: stop click bubbling so it doesn't open the host details
        const cb = div.querySelector('.host-select');
        if (cb) {
          cb.addEventListener('click', (e) => e.stopPropagation());
          cb.addEventListener('change', (e) => {
            e.stopPropagation();
            const aid = cb.getAttribute('data-agent-id');
            if (!aid) return;
            if (cb.checked) selectedAgentIds.add(aid);
            else selectedAgentIds.delete(aid);
            updateUpgradeControlsFn();
          });
        }
      });

      // Re-apply active highlight
      if (currentAgentId) {
        document.querySelectorAll('.host-item').forEach(item => {
          if (item.dataset.agentId === currentAgentId) item.classList.add('active');
        });
      }

      updateUpgradeControlsFn();
    }

    function clearCurrentHostSelection() {
      currentAgentId = null;
      metricsLifecycleState.set('currentMetricsAgentId', null);

      // Stop any existing metrics updates
      stopMetricsPolling(metricsLifecycleState);
      

      // Clear sidebar highlight
      document.querySelectorAll('.host-item').forEach(item => item.classList.remove('active'));

      // Hide host action buttons
      const hostActions = document.getElementById('host-actions');
      if (hostActions) hostActions.style.display = 'none';
      setHostActionActive(null);

      // Reset the overview panel to fleet overview placeholder
      const placeholder = document.getElementById('server-info-placeholder');
      const header = document.getElementById('server-info-header');
      if (placeholder) placeholder.style.display = 'block';
      if (header) header.style.display = 'none';
    }

    function selectHost(agentId, hostname) {
      const prevActiveTabId = document.querySelector('.tab-content-custom.active')?.id || 'server-info-tab';

      currentAgentId = agentId;

      // Reset per-host package filters so they don't leak across hosts
      packagesUpdatesOnly = false;
      const updatesOnlyEl = document.getElementById('packages-updates-only');
      if (updatesOnlyEl) updatesOnlyEl.checked = false;

      // Reset package selection when switching hosts (prevents stale selections and enables CVE pre-select)
      selectedPackages = new Set();
      const selPkgsEl = document.getElementById('select-visible-packages');
      if (selPkgsEl) selPkgsEl.checked = false;
      currentPackageName = null;
      const infoEl = document.getElementById('package-info');
      if (infoEl) infoEl.innerHTML = '';

      const hostActions = document.getElementById('host-actions');
      if (hostActions) hostActions.style.display = 'flex';

      // Stop any existing metrics updates
      stopMetricsPolling(metricsLifecycleState);

      // Clear load graph data when switching hosts
      loadGraphData = [];

      // Update active host in sidebar
      document.querySelectorAll('.host-item').forEach(item => {
        item.classList.remove('active');
        if (item.dataset.agentId === agentId) {
          item.classList.add('active');
        }
      });

      // Update header content for the host overview panel
      document.getElementById('server-info-placeholder').style.display = 'none';
      document.getElementById('server-info-header').style.display = 'block';
      document.getElementById('server-info-hostname').textContent = hostname;

      const hostObj = (allHosts || []).find(h => h.agent_id === agentId);

      const detailsEl = document.getElementById('server-info-details');
      if (detailsEl) {
        const agentText = hostObj?.agent_id ? escapeHtml(hostObj.agent_id) : 'n/a';
        const osParts = [];
        if (hostObj?.os_id) osParts.push(String(hostObj.os_id));
        if (hostObj?.os_version) osParts.push(String(hostObj.os_version));
        const osText = osParts.length ? escapeHtml(osParts.join(' ')) : 'n/a';
        detailsEl.innerHTML = `
          <span class="detail-pill">Agent ID: <code>${agentText}</code></span>
          <span class="detail-pill">OS: <code>${osText}</code></span>
        `;
      }

      const labelsEl = document.getElementById('server-info-labels');
      if (labelsEl) {
        const labels = (hostObj && hostObj.labels && typeof hostObj.labels === 'object') ? hostObj.labels : {};
        const env = labels.env ? String(labels.env) : '';
        const role = labels.role ? String(labels.role) : '';
        const parts = [];
        if (env) parts.push(`<span class="label-badge">env: <code>${escapeHtml(env)}</code></span>`);
        if (role) parts.push(`<span class="label-badge">role: <code>${escapeHtml(role)}</code></span>`);
        labelsEl.innerHTML = parts.length ? parts.join('') : `<span class="label-badge">env: <code>n/a</code></span><span class="label-badge">role: <code>n/a</code></span>`;
      }

      // Switch to the appropriate tab:
      // - If user is in Terminal/Users/Services/Packages, keep that tab when switching hosts.
      // - Otherwise default to the host overview (server-info-tab).
      const hostActionTabs = new Set(['terminal-tab', 'users-tab', 'services-tab', 'packages-tab']);
      const keepTabId = hostActionTabs.has(prevActiveTabId) ? prevActiveTabId : 'server-info-tab';

      document.querySelectorAll('.tab-content-custom, .tab-content').forEach(c => c.classList.remove('active'));
      document.getElementById(keepTabId)?.classList.add('active');

      // Keep the host-action button highlight consistent
      if (keepTabId === 'terminal-tab') setHostActionActive('terminal');
      else if (keepTabId === 'users-tab') setHostActionActive('users');
      else if (keepTabId === 'services-tab') setHostActionActive('services');
      else if (keepTabId === 'packages-tab') setHostActionActive('packages');
      else setHostActionActive(null);

      // Refresh tab-specific content
      if (keepTabId === 'terminal-tab') {
        connect(currentAgentId);
      } else if (keepTabId === 'users-tab') {
        loadUsers(currentAgentId);
      } else if (keepTabId === 'services-tab') {
        loadServices(currentAgentId);
      } else if (keepTabId === 'packages-tab') {
        loadPackages(currentAgentId);
        refreshPackagesNow(currentAgentId);
      } else {
        // Host overview: start metrics polling
        metricsLifecycleState.set('currentMetricsAgentId', agentId);
        loadHistoricalLoadData(agentId);
        loadMetrics(agentId);
        loadTopProcesses(agentId, true);

        metricsLifecycleState.set('metricsUpdateInterval', setInterval(() => {
          if (metricsLifecycleState.get('currentMetricsAgentId') === agentId &&
            document.getElementById('server-info-tab').classList.contains('active')) {
            loadMetrics(agentId, true);
          } else {
            stopMetricsPolling(metricsLifecycleState);
          }
        }, METRICS_POLL_MS));

        metricsLifecycleState.set('topProcessesUpdateInterval', setInterval(() => {
          if (metricsLifecycleState.get('currentMetricsAgentId') === agentId &&
            document.getElementById('server-info-tab').classList.contains('active')) {
            loadTopProcesses(agentId, true);
          } else {
            stopMetricsPolling(metricsLifecycleState);
          }
        }, TOP_PROCS_POLL_MS));
      }
    }

    async function loadTopProcesses(agentId, silent = true) {
      if (metricsLifecycleState.get('currentMetricsAgentId') !== agentId) return;
      if (metricsLifecycleState.get('topProcessesInFlight')) return; // avoid queueing jobs if server/agent is slow
      metricsLifecycleState.set('topProcessesInFlight', true);
      try {
        const resp = await fetch(`/hosts/${agentId}/top-processes`);
        if (!resp.ok) throw new Error(resp.statusText);
        const data = await resp.json();
        if (metricsLifecycleState.get('currentMetricsAgentId') !== agentId) return;
        updateTopProcessesTable(data.top_processes || []);
      } catch (e) {
        if (!silent) console.error('Error loading top processes:', e);
      } finally {
        metricsLifecycleState.set('topProcessesInFlight', false);
      }
    }

    async function loadMetrics(agentId, silent = false) {
      // Only update if this is still the current agent we're viewing
      if (metricsLifecycleState.get('currentMetricsAgentId') !== agentId) {
        return; // Ignore updates for other agents
      }

      if (!silent) {
        document.getElementById('disk-usage').textContent = 'Loading...';
        document.getElementById('memory-usage').textContent = 'Loading...';
        document.getElementById('vcpus').textContent = 'Loading...';
        document.getElementById('ip-addresses').textContent = 'Loading...';
      }

      try {
        const response = await fetch(`/hosts/${agentId}/metrics`);
        if (!response.ok) {
          throw new Error(`Failed to load metrics: ${response.statusText}`);
        }
        const data = await response.json();

        // Double-check we're still viewing this agent before updating UI
        if (metricsLifecycleState.get('currentMetricsAgentId') !== agentId) {
          return; // User switched to a different agent, ignore this response
        }

        // Update disk usage
        const disk = data.disk_usage || {};
        if (disk.percent_used !== undefined) {
          document.getElementById('disk-usage').textContent = `${disk.percent_used.toFixed(1)}%`;
          document.getElementById('disk-details').textContent =
            `${disk.used_gb.toFixed(1)} GB / ${disk.total_gb.toFixed(1)} GB used`;
          const pct = Number(disk.percent_used);
          document.getElementById('disk-bar').style.width = `${pct}%`;
          // green→red gradient based on usage
          const hue = 120 - (120 * (Math.max(0, Math.min(100, pct)) / 100));
          document.getElementById('disk-bar').style.background = `hsl(${hue} 85% 45%)`;
        }

        // Update memory
        const memory = data.memory || {};
        if (memory.percent_used !== undefined) {
          document.getElementById('memory-usage').textContent = `${memory.percent_used.toFixed(1)}%`;
          document.getElementById('memory-details').textContent =
            `${memory.used_gb.toFixed(2)} GB / ${memory.total_gb.toFixed(2)} GB used`;
          document.getElementById('memory-bar').style.width = `${memory.percent_used}%`;
        }

        // Update vCPUs
        const cpu = data.cpu || {};
        if (cpu.vcpus !== undefined) {
          document.getElementById('vcpus').textContent = cpu.vcpus;
        }

        // Update IP addresses
        const ips = data.ip_addresses || [];
        if (ips.length > 0) {
          document.getElementById('ip-addresses').textContent = ips.length;
          document.getElementById('ip-list').innerHTML = ips.map(ip =>
            `<div style="font-family: monospace; margin-top: 0.25rem;">${ip}</div>`
          ).join('');
        } else {
          document.getElementById('ip-addresses').textContent = '0';
          document.getElementById('ip-list').innerHTML = '';
        }

        // Update load graph
        if (cpu.load_1min !== undefined) {
          updateLoadGraph(cpu.load_1min);
        }

        // Top processes are now refreshed via /top-processes every second; keep this as a fallback.
        if (data.top_processes && data.top_processes.length) {
          updateTopProcessesTable(data.top_processes || []);
        }
      } catch (error) {
        console.error('Error loading metrics:', error);
        // Only show error if we're still viewing this agent
        if (metricsLifecycleState.get('currentMetricsAgentId') === agentId && !silent) {
          document.getElementById('disk-usage').textContent = 'Error';
          document.getElementById('memory-usage').textContent = 'Error';
          document.getElementById('vcpus').textContent = 'Error';
          document.getElementById('ip-addresses').textContent = 'Error';
        }
      }
    }

    function updateTopProcessesTable(processes) {
      const tbody = document.getElementById('top-processes-body');
      if (typeof window.renderTopProcessesTable === 'function') {
        window.renderTopProcessesTable(tbody, processes, escapeHtml);
        return;
      }
      if (!tbody) return;

      if (!processes || processes.length === 0) {
        tbody.innerHTML = '<tr><td colspan="5" style="text-align:center;color:#a0aec0;">No process data</td></tr>';
        return;
      }

      tbody.innerHTML = processes.slice(0, 10).map(p => {
        const pid = p.pid ?? '';
        const user = escapeHtml(p.user ?? '');
        const cpu = (p.cpu_percent ?? p.cpu ?? 0);
        const mem = (p.mem_percent ?? p.mem ?? 0);
        const cmd = escapeHtml(p.command ?? '');
        return `
          <tr>
            <td>${pid}</td>
            <td>${user}</td>
            <td>${Number(cpu).toFixed(1)}</td>
            <td>${Number(mem).toFixed(1)}</td>
            <td>${cmd}</td>
          </tr>
        `;
      }).join('');
    }

    async function loadHistoricalLoadData(agentId) {
      try {
        const limit = getLoadHistoryLimitForRange(loadTimeframeSeconds);
        const response = await fetch(`/hosts/${agentId}/load-history?since_seconds=${encodeURIComponent(loadTimeframeSeconds)}&limit=${encodeURIComponent(limit)}`);
        if (!response.ok) {
          console.warn('Failed to load historical load data:', response.statusText);
          return;
        }
        const data = await response.json();
        const history = data.history || [];

        // Convert historical data to our format
        loadGraphData = history.map(item => ({
          time: new Date(item.time),
          load: item.load_1min
        }));

        // Redraw graph with historical data
        if (loadGraphData.length > 0) {
          const canvas = document.getElementById('load-graph');
          const ctx = canvas.getContext('2d');
          canvas.width = canvas.offsetWidth;
          canvas.height = canvas.offsetHeight;
          redrawLoadGraph(ctx, canvas);
        }
      } catch (error) {
        console.error('Error loading historical load data:', error);
      }
    }

    function redrawLoadGraph(ctx, canvas) {
      if (loadGraphData.length < 2) return;

      // Layout
      const paddingTop = 26;
      const paddingBottom = 22; // room for time labels
      const paddingLeft = 6;
      const paddingRight = 6;
      const plotW = canvas.width - paddingLeft - paddingRight;
      const plotH = canvas.height - paddingTop - paddingBottom;

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Filter to timeframe (client-side safety)
      const now = Date.now();
      const minAllowed = now - loadTimeframeSeconds * 1000;
      const data = loadGraphData.filter(p => p.time && p.time.getTime() >= minAllowed);
      if (data.length < 2) return;

      // Find max load for scaling
      const maxLoad = Math.max(...data.map(d => d.load), 1) * 1.1;

      const minT = data[0].time.getTime();
      const maxT = data[data.length - 1].time.getTime();
      const rangeT = Math.max(1, maxT - minT);

      // Draw grid
      ctx.strokeStyle = '#e2e8f0';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 5; i++) {
        const y = paddingTop + (plotH / 5) * i;
        ctx.beginPath();
        ctx.moveTo(paddingLeft, y);
        ctx.lineTo(canvas.width - paddingRight, y);
        ctx.stroke();
      }

      // Draw load line
      ctx.strokeStyle = '#667eea';
      ctx.lineWidth = 2;
      ctx.beginPath();

      data.forEach((point, index) => {
        const t = point.time.getTime();
        const x = paddingLeft + ((t - minT) / rangeT) * plotW;
        const y = paddingTop + (plotH - (point.load / maxLoad) * plotH);

        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });

      ctx.stroke();

      // Draw timestamp labels (start / mid / end)
      ctx.fillStyle = '#718096';
      ctx.font = '11px sans-serif';
      ctx.textBaseline = 'top';
      ctx.textAlign = 'left';
      const startLabel = formatTimeLabel(new Date(minT), loadTimeframeSeconds);
      const endLabel = formatTimeLabel(new Date(maxT), loadTimeframeSeconds);
      ctx.fillText(startLabel, paddingLeft, canvas.height - paddingBottom + 4);
      ctx.textAlign = 'right';
      ctx.fillText(endLabel, canvas.width - paddingRight, canvas.height - paddingBottom + 4);

      // Draw current load + timestamp
      const last = data[data.length - 1];
      ctx.fillStyle = '#667eea';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'alphabetic';
      ctx.fillText(`Load: ${last.load.toFixed(2)} @ ${formatTimeLabel(last.time, loadTimeframeSeconds)}`, 10, 20);
    }

    function updateLoadGraph(loadValue) {
      const canvas = document.getElementById('load-graph');
      const ctx = canvas.getContext('2d');

      // Add new data point
      loadGraphData.push({
        time: new Date(),
        load: loadValue
      });

      // Keep only points within selected timeframe (plus small buffer)
      const cutoff = Date.now() - (loadTimeframeSeconds * 1000) - 5000;
      while (loadGraphData.length > 0 && loadGraphData[0].time.getTime() < cutoff) {
        loadGraphData.shift();
      }

      // Safety cap to avoid huge arrays in the browser
      const cap = getLoadHistoryLimitForRange(loadTimeframeSeconds);
      if (loadGraphData.length > cap) {
        loadGraphData = loadGraphData.slice(loadGraphData.length - cap);
      }

      // Set canvas size
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;

      // Redraw the entire graph
      redrawLoadGraph(ctx, canvas);
    }

    function showTerminal() {
      if (!currentAgentId) return;
      setHostActionActive('terminal');
      // Stop metrics updates when leaving server info view
      stopMetricsPolling(metricsLifecycleState);
      connect(currentAgentId);
      document.querySelectorAll('.tab-content-custom, .tab-content').forEach(c => c.classList.remove('active'));
      document.getElementById('terminal-tab').classList.add('active');
    }

    function showUsers() {
      if (!currentAgentId) return;
      setHostActionActive('users');
      // Stop metrics updates when leaving server info view
      stopMetricsPolling(metricsLifecycleState);
      document.querySelectorAll('.tab-content-custom, .tab-content').forEach(c => c.classList.remove('active'));
      document.getElementById('users-tab').classList.add('active');
      loadUsers(currentAgentId);
    }

    function showServices() {
      if (!currentAgentId) return;
      setHostActionActive('services');
      // Stop metrics updates when leaving server info view
      stopMetricsPolling(metricsLifecycleState);
      document.querySelectorAll('.tab-content-custom, .tab-content').forEach(c => c.classList.remove('active'));
      document.getElementById('services-tab').classList.add('active');
      loadServices(currentAgentId);
    }

    function showPackages() {
      if (!currentAgentId) return;
      setHostActionActive('packages');
      // Stop metrics updates when leaving server info view
      stopMetricsPolling(metricsLifecycleState);
      document.querySelectorAll('.tab-content-custom, .tab-content').forEach(c => c.classList.remove('active'));
      document.getElementById('packages-tab').classList.add('active');
      // Load what's in DB immediately, then trigger an on-demand inventory refresh and reload.
      loadPackages(currentAgentId);
      refreshPackagesNow(currentAgentId);
    }

    function showServerInfo() {
      if (!currentAgentId) return;
      const hostObj = (allHosts || []).find(h => h.agent_id === currentAgentId);
      const hostname = hostObj?.hostname || currentAgentId;
      selectHost(currentAgentId, hostname);
    }

    async function loadAdminAudit(showToastOnManual = false) {
      const tbody = document.getElementById('admin-audit-table');
      const statusEl = document.getElementById('admin-audit-status');
      if (!tbody) return;

      const action = (document.getElementById('audit-filter-action')?.value || '').trim();
      const actor = (document.getElementById('audit-filter-actor')?.value || '').trim();

      try {
        setTableState(tbody, 6, 'loading', 'Loading…');
        if (statusEl) statusEl.textContent = '';

        const qs = new URLSearchParams();
        if (action) qs.set('action', action);
        if (actor) qs.set('actor', actor);
        qs.set('limit', '200');

        const r = await fetch(`/audit?${qs.toString()}`, { credentials: 'include' });
        const raw = await r.text();
        let d = null; try { d = raw ? JSON.parse(raw) : null; } catch {}
        if (!r.ok) throw new Error((d && (d.detail || d.error)) || raw || `audit fetch failed (${r.status})`);

        const items = (d && d.items) ? d.items : [];
        if (!items.length) {
          setTableState(tbody, 6, 'empty', 'No events');
          return;
        }
        tbody.innerHTML = '';
        for (const ev of items) {
          const tr = document.createElement('tr');
          const when = formatShortTime(ev.created_at || '');
          const who = String(ev.actor || '');
          const actionName = String(ev.action || '');
          const target = (ev.target_type || ev.target_name) ? `${String(ev.target_type||'')}:${String(ev.target_name||'')}` : '';
          const ip = String(ev.ip || '');
          const meta = safeJsonPreview(ev.meta || {}, 160);
          tr.innerHTML = `
            <td style="color:#94a3b8;">${escapeHtml(when)}</td>
            <td><a href="#" data-audit-id="${escapeHtml(String(ev.id||''))}" style="text-decoration:underline;color:inherit;"><code>${escapeHtml(actionName)}</code></a></td>
            <td>${escapeHtml(who)}</td>
            <td style="color:#94a3b8;">${escapeHtml(target)}</td>
            <td style="color:#94a3b8;"><code>${escapeHtml(ip)}</code></td>
            <td style="color:#94a3b8;"><code>${escapeHtml(meta)}</code></td>
          `;
          tbody.appendChild(tr);
        }

        tbody.querySelectorAll('a[data-audit-id]').forEach(a => {
          a.addEventListener('click', async (e) => {
            e.preventDefault();
            const id = a.getAttribute('data-audit-id') || '';
            if (!id) return;
            try {
              const r2 = await fetch(`/audit/${encodeURIComponent(id)}`, { credentials: 'include' });
              const raw2 = await r2.text();
              let d2 = null; try { d2 = raw2 ? JSON.parse(raw2) : null; } catch {}
              if (!r2.ok) throw new Error((d2 && (d2.detail||d2.error)) || raw2 || 'Audit event load failed');

              const pretty = JSON.stringify(d2.meta || {}, null, 2);

              // Show in a large, copyable modal instead of alert().
              const modal = document.getElementById('audit-detail-modal');
              const titleEl = document.getElementById('audit-detail-modal-title');
              const outEl = document.getElementById('audit-detail-modal-output');
              const metaEl = document.getElementById('audit-detail-modal-meta');
              if (modal && titleEl && outEl && metaEl) {
                titleEl.textContent = `Audit event: ${d2.action || ''}`;
                metaEl.textContent = `Time: ${d2.created_at || ''} · Actor: ${d2.actor || ''} · Target: ${(d2.target_type||'')}:${(d2.target_name||'')} · IP: ${d2.ip || ''}`;
                outEl.value = pretty;
                modal.hidden = false;
                modal.classList.add('open');
                modal.setAttribute('aria-hidden', 'false');
              } else {
                alert(
                  `Audit event\n\n` +
                  `Time: ${d2.created_at || ''}\n` +
                  `Action: ${d2.action || ''}\n` +
                  `Actor: ${d2.actor || ''}\n` +
                  `Target: ${(d2.target_type||'')}:${(d2.target_name||'')}\n` +
                  `IP: ${d2.ip || ''}\n\n` +
                  `Meta:\n${pretty}`
                );
              }
            } catch (err) {
              showToast(err.message || String(err), 'error', 5000);
            }
          });
        });

        if (showToastOnManual) showToast('Audit refreshed', 'success');
      } catch (e) {
        setTableState(tbody, 6, 'error', e.message || String(e));
        if (statusEl) statusEl.textContent = e.message;
        if (showToastOnManual) showToast(e.message, 'error');
      }
    }

    async function loadAdminUsers(showToastOnManual = false) {
      const tbody = document.getElementById('admin-users-table');
      const statusEl = document.getElementById('admin-users-status');
      if (!tbody) return;

      try {
        setTableState(tbody, 6, 'loading', 'Loading…');
        if (statusEl) statusEl.textContent = '';
        const r = await fetch('/auth/admin/users', { credentials: 'include' });
        const raw = await r.text();
        let d = null; try { d = raw ? JSON.parse(raw) : null; } catch {}
        if (!r.ok) throw new Error((d && (d.detail || d.error)) || raw || `users list failed (${r.status})`);

        const items = (d && d.items) ? d.items : [];
        if (!items.length) {
          setTableState(tbody, 6, 'empty', 'No users');
          return;
        }
        tbody.innerHTML = '';
        for (const u of items) {
          const tr = document.createElement('tr');
          const role = String(u.role || 'operator');
          const active = (u.active === false) ? 'no' : 'yes';
          const mfa = u.mfa_enabled ? 'enabled' : 'off';
          const created = formatShortTime(u.created_at || '');
          const uname = String(u.username || '');
          const bootstrap = String(adminUsername || 'admin');
          const canDelete = !!(currentPermissions && currentPermissions.can_delete_app_users) && uname && uname !== bootstrap && uname !== currentUsername;

          tr.innerHTML = `
            <td><code>${escapeHtml(uname)}</code></td>
            <td>${escapeHtml(role)}</td>
            <td>${escapeHtml(active)}</td>
            <td>${escapeHtml(mfa)}</td>
            <td style="color:#94a3b8;">${escapeHtml(created)}</td>
            <td style="text-align:right;white-space:nowrap;">
              <button class="btn" data-user-delete="${escapeHtml(uname)}" ${canDelete ? '' : 'disabled'} title="${canDelete ? 'Deactivate user' : 'Cannot delete this user'}">Delete</button>
            </td>
          `;
          tbody.appendChild(tr);
        }

        tbody.querySelectorAll('button[data-user-delete]').forEach(btn => {
          btn.addEventListener('click', async (e) => {
            e.preventDefault();
            const uname = btn.getAttribute('data-user-delete') || '';
            if (!uname) return;
            const ok = confirm(`Deactivate user '${uname}'?\n\nThis will disable login and revoke sessions.`);
            if (!ok) return;
            try {
              const r2 = await fetch(`/auth/users/${encodeURIComponent(uname)}/delete`, { method: 'POST', credentials: 'include', headers: { 'X-CSRF-Token': (getCookie('fleet_csrf')||'') } });
              const raw2 = await r2.text();
              let d2 = null; try { d2 = raw2 ? JSON.parse(raw2) : null; } catch {}
              if (!r2.ok) throw new Error((d2 && (d2.detail||d2.error)) || raw2 || 'Delete failed');
              showToast(`User '${uname}' deactivated`, 'success');
              loadAdminUsers();
              loadAdminAudit();
            } catch (err) {
              showToast(err.message || String(err), 'error', 5000);
            }
          });
        });

        if (showToastOnManual) showToast('Users refreshed', 'success');
      } catch (e) {
        setTableState(tbody, 6, 'error', e.message || String(e));
        if (statusEl) statusEl.textContent = e.message;
        if (showToastOnManual) showToast(e.message, 'error');
      }
    }

    function showAdminPage() {
      // Stop metrics updates when leaving server info view
      stopMetricsPolling(metricsLifecycleState);
      document.querySelectorAll('.tab-content-custom, .tab-content').forEach(c => c.classList.remove('active'));
      document.getElementById('admin-tab').classList.add('active');
      loadAdminUsers();
      loadAdminAudit();
    }

    const setHostActionActive = window.setHostActionActive || function(action) {
      document.querySelectorAll('.host-action-btn').forEach(btn => btn.classList.remove('active'));
      const map = {
        terminal: 'host-action-terminal',
        users: 'host-action-users',
        services: 'host-action-services',
        packages: 'host-action-packages'
      };
      const id = map[action];
      const target = id ? document.getElementById(id) : null;
      if (target) target.classList.add('active');
    };

    function connect(agentId) {
      const run = window.connectTerminalSession;
      if (typeof run === 'function') {
        run({
          agentId,
          term,
          getWs: () => ws,
          setWs: (next) => { ws = next; },
          setCurrentAgentId: (next) => { currentAgentId = next; }
        });
        return;
      }

      currentAgentId = agentId;
      if (ws) { try { ws.close(); } catch { } }
      term.clear();
      term.write(`Connecting to ${agentId}...\r\n`);
      const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${protocol}//${location.host}/ws/terminal/${agentId}`);
      ws.binaryType = "arraybuffer";
    }

    async function loadHosts() {
      try {
        const response = await fetch('/hosts?online_only=true');
        const hosts = await response.json();
        allHosts = syncHostFilterSelectionState('allHosts', hosts || []);

        // Refresh label filter options from the latest host list
        rebuildLabelFilterOptions(allHosts);

        if (allHosts.length === 0) {
          document.getElementById('hosts').innerHTML = '<div class="empty-state">No hosts found</div>';
          return;
        }

        applyHostFilters();
      } catch (error) {
        document.getElementById('hosts').innerHTML = `<div class="error">Error loading hosts: ${error.message}</div>`;
      }
    }

    function initHostFilters() {
      const searchEl = document.getElementById('host-search');
      const envSel = document.getElementById('label-env');
      const roleSel = document.getElementById('label-role');
      const labelsClearBtn = document.getElementById('labels-clear');
      const labelsSection = document.getElementById('labels-filter-section');
      const labelsToggle = document.getElementById('labels-filter-toggle');
      const labelsToggleBtn = document.getElementById('labels-toggle-btn');
      const cveEl = document.getElementById('vuln-cve');
      const pkgEl = document.getElementById('vuln-package');
      const verEl = document.getElementById('vuln-version');
      const applyBtn = document.getElementById('vuln-apply');
      const clearBtn = document.getElementById('vuln-clear');
      const statusEl = document.getElementById('vuln-status');
      const selectVisibleEl = document.getElementById('select-visible-hosts');
      const upgradeBtn = document.getElementById('upgrade-selected');
      const upgradeStatusEl = document.getElementById('upgrade-status');
      const cvePackagesPanel = document.getElementById('cve-packages-panel');
      const cvePackagesList = document.getElementById('cve-packages-list');
      const cvePlanSummaryEl = document.getElementById('cve-plan-summary');
      const vulnSection = document.getElementById('vuln-filter-section');
      const vulnToggle = document.getElementById('vuln-filter-toggle');
      const vulnToggleBtn = document.getElementById('vuln-toggle-btn');
      const ansibleSection = document.getElementById('ansible-filter-section');
      const ansibleToggle = document.getElementById('ansible-filter-toggle');
      const ansibleToggleBtn = document.getElementById('ansible-toggle-btn');

      if (searchEl) {
        searchEl.addEventListener('input', () => {
          hostSearchQuery = syncHostFilterSelectionState('hostSearchQuery', searchEl.value || '');
          applyHostFilters();
        });
      }

      function setLabelsOpen(open) {
        if (!labelsSection || !labelsToggleBtn) return;
        labelsSection.classList.toggle('open', open);
        labelsToggleBtn.textContent = open ? '−' : '+';
        labelsToggleBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
      }

      // Default: collapsed
      setLabelsOpen(false);
      setAnsibleOpen(false);

      // Toggle open/close when clicking the header
      labelsToggle?.addEventListener('click', (e) => {
        // Don't toggle when interacting with the selects in the body
        if (e.target && (e.target.id === 'label-env' || e.target.id === 'label-role')) return;
        e.preventDefault();
        const isOpen = labelsSection?.classList.contains('open');
        setLabelsOpen(!isOpen);
      });

      function setAnsibleOpen(open) {
        if (!ansibleSection || !ansibleToggleBtn) return;
        ansibleSection.classList.toggle('open', open);
        ansibleToggleBtn.textContent = open ? '−' : '+';
        ansibleToggleBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
      }

      ansibleToggle?.addEventListener('click', (e) => {
        e.preventDefault();
        const isOpen = ansibleSection?.classList.contains('open');
        setAnsibleOpen(!isOpen);
      });

      function onLabelsChanged() {
        labelEnvFilter = syncHostFilterSelectionState('labelEnvFilter', envSel?.value || '');
        labelRoleFilter = syncHostFilterSelectionState('labelRoleFilter', roleSel?.value || '');
        applyHostFilters();
      }
      envSel?.addEventListener('change', onLabelsChanged);
      roleSel?.addEventListener('change', onLabelsChanged);
      labelsClearBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        if (envSel) envSel.value = '';
        if (roleSel) roleSel.value = '';
        labelEnvFilter = syncHostFilterSelectionState('labelEnvFilter', '');
        labelRoleFilter = syncHostFilterSelectionState('labelRoleFilter', '');
        applyHostFilters();
      });

      function setVulnOpen(open) {
        if (!vulnSection || !vulnToggleBtn) return;
        vulnSection.classList.toggle('open', open);
        vulnToggleBtn.textContent = open ? '−' : '+';
        vulnToggleBtn.setAttribute('aria-expanded', open ? 'true' : 'false');
      }

      // Default: collapsed
      setVulnOpen(false);

      // Toggle open/close when clicking the header or the + button
      vulnToggle?.addEventListener('click', (e) => {
        // Prevent focusing inputs from toggling
        if (e.target && (e.target.id === 'vuln-cve' || e.target.id === 'vuln-package' || e.target.id === 'vuln-version')) return;
        e.preventDefault();
        const isOpen = vulnSection?.classList.contains('open');
        setVulnOpen(!isOpen);
      });

      async function applyVulnFilter() {
        const cve = (cveEl?.value || '').trim().toUpperCase();
        const name = (pkgEl?.value || '').trim();
        const version = (verEl?.value || '').trim();

        if (!cve && !name) {
          if (statusEl) statusEl.textContent = 'Enter a CVE or a package name.';
          setVulnOpen(true);
          return;
        }

        if (statusEl) statusEl.textContent = cve ? 'Running CVE check…' : 'Searching…';
        if (applyBtn) applyBtn.disabled = true;
        if (clearBtn) clearBtn.disabled = true;

        try {
          if (cve) {
            if (!/^CVE-\d{4}-\d{4,}$/i.test(cve)) {
              throw new Error('Invalid CVE format. Example: CVE-2021-45105');
            }

            // Run on all currently loaded online hosts.
            const targets = (allHosts || []).map(h => h.agent_id).filter(Boolean);
            if (!targets.length) throw new Error('No hosts loaded');

            const resp0 = await fetch('/jobs/cve-check', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ agent_ids: targets, cve })
            });
            if (!resp0.ok) {
              let msg = resp0.statusText;
              try { const err = await resp0.json(); msg = err.detail || err.message || msg; } catch { }
              throw new Error(msg);
            }
            const out = await resp0.json();
            const jobId = out.job_id;
            if (statusEl) statusEl.textContent = `CVE check started (job_id: ${jobId}). Waiting…`;

            const data = await pollJob(jobId, statusEl, 180000);
            const affectedIds = [];
            const resultsByAgentId = {};

            for (const r of (data?.runs || [])) {
              if (r.status !== 'success' || !r.stdout) continue;
              try {
                const j = JSON.parse(r.stdout);
                const affected = !!(j && j.affected === true);
                const pkgs = Array.isArray(j?.packages) ? j.packages.filter(Boolean) : [];
                resultsByAgentId[r.agent_id] = { affected, packages: pkgs };
                if (affected) affectedIds.push(r.agent_id);
              } catch { }
            }

            lastCveCheck = { cve, resultsByAgentId };
            lastCveAffectedAgentIds = affectedIds;

            // Build union of affected packages across affected hosts
            const union = new Set();
            for (const aid of affectedIds) {
              const r = resultsByAgentId[aid];
              const pk = Array.isArray(r?.packages) ? r.packages : [];
              pk.forEach(p => { if (p) union.add(p); });
            }
            lastCveUnionPackages = Array.from(union).sort();
            selectedCvePackages = new Set(lastCveUnionPackages);

            // If nothing is affected, don't apply a filter that hides everything.
            vulnFilteredAgentIds = syncHostFilterSelectionState('vulnFilteredAgentIds', affectedIds.length ? new Set(affectedIds) : null);
            if (statusEl) {
              const total = targets.length;
              const scopeMsg = affectedIds.length ? `Showing ${affectedIds.length} affected host(s) in the list.` : `Showing all hosts (none affected).`;
              statusEl.textContent = `CVE ${cve}: ${affectedIds.length}/${total} host(s) affected (online). Affected packages: ${lastCveUnionPackages.length}. ${scopeMsg}`;
            }
          } else {
            const params = new URLSearchParams({ name });
            if (version) params.set('version', version);
            const resp = await fetch(`/search/packages?${params.toString()}`);
            if (!resp.ok) throw new Error(resp.statusText);
            const rows = await resp.json();
            vulnFilteredAgentIds = syncHostFilterSelectionState('vulnFilteredAgentIds', new Set((rows || []).map(r => r.agent_id)));
            lastCveCheck = null; // switching modes
            if (statusEl) statusEl.textContent = `Package ${name}: ${vulnFilteredAgentIds.size} host(s) matched.`;
          }

          if (clearBtn) clearBtn.disabled = false;
          // Reset selection when changing vuln filter to avoid hidden selections
          selectedAgentIds = syncHostFilterSelectionState('selectedAgentIds', new Set());
          if (selectVisibleEl) selectVisibleEl.checked = false;
          // Reset last verification (different host set now)
          lastPkgVerification = null;

          // CVE results are only meaningful for the current CVE run; keep them.
          // (If user later switches to package search, we'll clear it there.)

          applyHostFilters();
          setVulnOpen(true);

          // New UX: stay on the Hosts view. Show affected packages + allow targeted upgrade from here.
          updateUpgradeControlsFn();

        } catch (e) {
          vulnFilteredAgentIds = syncHostFilterSelectionState('vulnFilteredAgentIds', null);
          if (statusEl) statusEl.textContent = `Error searching: ${e.message || e}`;
          applyHostFilters();
          setVulnOpen(true);
        } finally {
          if (applyBtn) applyBtn.disabled = false;
        }
      }

      function clearVulnFilter() {
        vulnFilteredAgentIds = syncHostFilterSelectionState('vulnFilteredAgentIds', null);
        if (statusEl) statusEl.textContent = '';
        if (clearBtn) clearBtn.disabled = true;
        if (cveEl) cveEl.value = '';
        if (pkgEl) pkgEl.value = '';
        if (verEl) verEl.value = '';
        // Reset selection when clearing vuln filter
        selectedAgentIds = syncHostFilterSelectionState('selectedAgentIds', new Set());
        if (selectVisibleEl) selectVisibleEl.checked = false;
        // Reset verification
        lastPkgVerification = null;
        lastCveCheck = null;
        lastCveAffectedAgentIds = [];
        lastCveUnionPackages = [];
        selectedCvePackages = new Set();
        applyHostFilters();
        updateUpgradeControlsFn();
      }

      applyBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        applyVulnFilter();
      });
      clearBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        clearVulnFilter();
      });

      function renderCvePackagesPanel(cve) {
        if (!cvePackagesPanel || !cvePackagesList) return;
        if (!cve || !lastCveCheck || lastCveCheck.cve !== cve || !Array.isArray(lastCveUnionPackages) || lastCveUnionPackages.length === 0) {
          cvePackagesPanel.style.display = 'none';
          cvePackagesList.innerHTML = '';
          if (cvePlanSummaryEl) cvePlanSummaryEl.innerHTML = '';
          selectedCvePackages = new Set();
          return;
        }

        cvePackagesPanel.style.display = 'block';
        // Default select all on first render
        if (!selectedCvePackages || selectedCvePackages.size === 0) {
          selectedCvePackages = new Set(lastCveUnionPackages);
        }

        cvePackagesList.innerHTML = lastCveUnionPackages.map(p => {
          const checked = selectedCvePackages.has(p);
          return `
            <label style="display:flex;gap:0.5rem;align-items:center;">
              <input type="checkbox" class="cve-pkg-cb" data-pkg="${escapeHtml(p)}" ${checked ? 'checked' : ''} />
              <span style="font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;font-size:0.9rem;">${escapeHtml(p)}</span>
            </label>
          `;
        }).join('');

        cvePackagesList.querySelectorAll('input.cve-pkg-cb[data-pkg]').forEach(cb => {
          cb.addEventListener('change', () => {
            const p = cb.getAttribute('data-pkg');
            if (!p) return;
            if (cb.checked) selectedCvePackages.add(p);
            else selectedCvePackages.delete(p);
            updateUpgradeControlsFn();
          });
        });
      }

      updateUpgradeControlsFn = function updateUpgradeControls() {
        const pkgName = (pkgEl?.value || '').trim();
        const cve = (cveEl?.value || '').trim().toUpperCase();
        const totalSelected = selectedAgentIds.size;
        const visibleSelected = lastRenderedAgentIds.filter(aid => selectedAgentIds.has(aid)).length;

        // CVE mode: show package checklist and enable upgrade when hosts+packages selected.
        const isCveMode = !!cve && lastCveCheck && lastCveCheck.cve === cve && Array.isArray(lastCveUnionPackages) && lastCveUnionPackages.length > 0;
        renderCvePackagesPanel(isCveMode ? cve : '');

        // In CVE mode, only enable upgrade if at least one selected host has at least one effective package.
        let effectiveTotalPkgs = 0;
        let effectiveHostsWithPkgs = 0;
        let effectiveHostsWithoutPkgs = 0;

        if (isCveMode && selectedCvePackages && selectedCvePackages.size > 0) {
          const selectedHosts = Array.from(selectedAgentIds);
          for (const aid of selectedHosts) {
            const r = lastCveCheck?.resultsByAgentId?.[aid];
            const pk = Array.isArray(r?.packages) ? r.packages : [];
            const eff = pk.filter(p => selectedCvePackages.has(p));
            if (eff.length > 0) {
              effectiveHostsWithPkgs += 1;
              effectiveTotalPkgs += eff.length;
            } else {
              effectiveHostsWithoutPkgs += 1;
            }
          }
        }

        const canRun = isCveMode
          ? (totalSelected > 0 && selectedCvePackages && selectedCvePackages.size > 0 && effectiveTotalPkgs > 0)
          : (totalSelected > 0 && !!pkgName);

        if (upgradeBtn) upgradeBtn.disabled = !canRun;

        if (cvePlanSummaryEl) {
          if (isCveMode) {
            const selectedPkgs = Array.from(selectedCvePackages || []).sort();
            const selectedHosts = Array.from(selectedAgentIds);

            const planLines = [];
            planLines.push(`<div><b>Plan:</b> ${selectedHosts.length} host(s), ${selectedPkgs.length} package(s) selected.</div>`);

            if (selectedHosts.length > 0) {
              planLines.push(`<div><b>Effective upgrades:</b> ${effectiveHostsWithPkgs}/${selectedHosts.length} host(s), ${effectiveTotalPkgs} package upgrade(s) total.</div>`);

              // Show per-host counts (compact)
              const rows = selectedHosts.map(aid => {
                const r = lastCveCheck?.resultsByAgentId?.[aid];
                const pk = Array.isArray(r?.packages) ? r.packages : [];
                const eff = pk.filter(p => selectedCvePackages.has(p));
                return `<div style="display:flex;justify-content:space-between;gap:8px;"><span><code>${escapeHtml(aid)}</code></span><span>${eff.length} pkg(s)</span></div>`;
              }).join('');
              planLines.push(`<details style="margin-top:4px"><summary>Per-host package counts</summary><div style="margin-top:4px">${rows}</div></details>`);

              if (effectiveTotalPkgs === 0) {
                planLines.push(`<div style="margin-top:4px;color:#fbbf24">No selected packages apply to the selected host(s).</div>`);
              }
            }

            cvePlanSummaryEl.innerHTML = planLines.join('');
          } else {
            cvePlanSummaryEl.innerHTML = '';
          }
        }

        if (upgradeStatusEl) {
          if (isCveMode) {
            upgradeStatusEl.textContent = `Selected: ${visibleSelected} visible / ${totalSelected} total host(s). CVE: ${cve}. Packages selected: ${(selectedCvePackages && selectedCvePackages.size) ? selectedCvePackages.size : 0}.`;
          } else if (pkgName) {
            upgradeStatusEl.textContent = `Selected: ${visibleSelected} visible / ${totalSelected} total host(s). Package: ${pkgName}`;
          } else if (cve) {
            upgradeStatusEl.textContent = `Selected: ${visibleSelected} visible / ${totalSelected} total host(s). CVE: ${cve}. (Run CVE check to see affected packages.)`;
          } else {
            upgradeStatusEl.textContent = `Selected: ${visibleSelected} visible / ${totalSelected} total host(s). Enter a CVE or package name.`;
          }
        }
      };

      selectVisibleEl?.addEventListener('change', () => {
        if (selectVisibleEl.checked) {
          // Replace selection with ONLY currently visible hosts (prevents hidden selections)
          selectedAgentIds = syncHostFilterSelectionState('selectedAgentIds', new Set(lastRenderedAgentIds));
        } else {
          // Clear selection (simpler + less confusing than keeping hidden selections)
          selectedAgentIds = syncHostFilterSelectionState('selectedAgentIds', new Set());
        }
        applyHostFilters(); // re-render to update checkbox states + status text
        updateUpgradeControlsFn();
      });

      async function upgradeSelected() {
        const pkgName = (pkgEl?.value || '').trim();
        const vulnVersion = (verEl?.value || '').trim();
        const cve = (cveEl?.value || '').trim().toUpperCase();

        const agentIds = Array.from(selectedAgentIds);
        if (agentIds.length === 0) {
          if (upgradeStatusEl) upgradeStatusEl.textContent = 'Select at least one host.';
          setVulnOpen(true);
          return;
        }

        const isCveMode = !!cve && lastCveCheck && lastCveCheck.cve === cve && selectedCvePackages && selectedCvePackages.size > 0;

        // Build per-agent package list (host-specific), filtered by the selected package checklist.
        let packagesByAgent = null;
        if (isCveMode) {
          packagesByAgent = {};
          for (const aid of agentIds) {
            const r = lastCveCheck?.resultsByAgentId?.[aid];
            const pk = Array.isArray(r?.packages) ? r.packages : [];
            const filtered = pk.filter(p => selectedCvePackages.has(p));
            if (filtered.length) packagesByAgent[aid] = filtered;
          }
          if (Object.keys(packagesByAgent).length === 0) {
            if (upgradeStatusEl) upgradeStatusEl.textContent = 'No selected packages apply to the selected hosts.';
            return;
          }
        }

        // Fallback: manual package name (non-CVE mode)
        const chosenPkg = pkgName;
        if (!isCveMode && !chosenPkg) {
          if (upgradeStatusEl) upgradeStatusEl.textContent = 'Enter a package name (or run a CVE check to populate affected packages).';
          setVulnOpen(true);
          return;
        }

        if (upgradeStatusEl) {
          upgradeStatusEl.textContent = isCveMode
            ? `Starting CVE upgrade on ${agentIds.length} host(s)…`
            : `Starting upgrade of ${chosenPkg} on ${agentIds.length} host(s)…`;
        }
        if (upgradeBtn) upgradeBtn.disabled = true;

        try {
          const body = isCveMode
            ? { agent_ids: agentIds, packages_by_agent: packagesByAgent }
            : { agent_ids: agentIds, packages: [chosenPkg] };

          const resp = await fetch('/jobs/pkg-upgrade', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
          });
          if (!resp.ok) {
            let msg = resp.statusText;
            try {
              const err = await resp.json();
              msg = err.detail || err.message || msg;
            } catch { }
            throw new Error(msg);
          }
          const out = await resp.json();
          const jobId = out.job_id;
          const targets = out.targets || agentIds;

          if (upgradeStatusEl) {
            const logsUrl = `/jobs/${encodeURIComponent(jobId)}/logs.zip`;
            upgradeStatusEl.innerHTML = `Upgrade job started (job_id: <code>${escapeHtml(jobId)}</code>). <a href="${logsUrl}" target="_blank" rel="noopener noreferrer">Download logs.zip</a>. Waiting…`;
          }

          await pollUpgradeJob(jobId, targets, isCveMode ? 'cve' : chosenPkg, upgradeStatusEl);

          if (!isCveMode) {
            // Verify installed version after upgrade (real check, not just job success)
            if (upgradeStatusEl) upgradeStatusEl.textContent = `Upgrade finished. Verifying installed version of ${chosenPkg}…`;
            await verifyPackageVersions(targets, chosenPkg, vulnVersion, upgradeStatusEl);
          } else {
            // We do NOT auto-clear the CVE finding until we re-run the CVE check.
            // However, after a remediation action, keeping the old checklist selected is confusing.
            // Hide it and disable Upgrade until the user re-runs the CVE check.
            lastCveUnionPackages = [];
            selectedCvePackages = new Set();
            updateUpgradeControlsFn();

            if (upgradeStatusEl) {
              const rerunId = `rerun-cve-${jobId}`;
              upgradeStatusEl.innerHTML =
                `Upgrade finished. ` +
                `<a href="/jobs/${encodeURIComponent(jobId)}/logs.zip" target="_blank" rel="noopener noreferrer">Download logs.zip</a>. ` +
                `<button id="${rerunId}" class="btn btn-sm" type="button" style="margin-left:6px">Re-run CVE check</button>`;

              // Wire up rerun button (keep it local; if it disappears due to other UI updates, no harm)
              setTimeout(() => {
                const btn = document.getElementById(rerunId);
                if (!btn) return;
                btn.onclick = async () => {
                  try {
                    if (cveEl && lastCveCheck && lastCveCheck.cve) {
                      cveEl.value = lastCveCheck.cve;
                    }
                    await applyVulnFilter();
                  } catch (e2) {
                    upgradeStatusEl.textContent = `Re-run failed: ${e2.message || e2}`;
                  }
                };
              }, 0);
            }
          }
        } catch (e) {
          if (upgradeStatusEl) upgradeStatusEl.textContent = `Upgrade failed: ${e.message || e}`;
        } finally {
          updateUpgradeControlsFn();
        }
      }

      let activeUpgradePoll = { cancelled: false, jobId: null };

      function summarizeRuns(runs, targets) {
        const byAgent = new Map();
        (runs || []).forEach(r => byAgent.set(r.agent_id, r.status));
        const statuses = targets.map(aid => byAgent.get(aid) || 'queued');
        const counts = statuses.reduce((acc, s) => {
          acc[s] = (acc[s] || 0) + 1;
          return acc;
        }, {});
        const done = (counts.success || 0) + (counts.failed || 0);
        const total = targets.length;
        return { counts, done, total, allDone: done === total };
      }

      async function pollUpgradeJob(jobId, targets, pkgName, statusEl) {
        // Cancel any existing polling for a different job
        if (activeUpgradePoll && activeUpgradePoll.jobId && activeUpgradePoll.jobId !== jobId) {
          activeUpgradePoll.cancelled = true;
        }
        activeUpgradePoll = { cancelled: false, jobId };

        const startedAt = Date.now();
        const timeoutMs = 10 * 60 * 1000; // 10 minutes
        let intervalMs = 1000;

        while (Date.now() - startedAt < timeoutMs) {
          if (activeUpgradePoll.cancelled) return;

          try {
            const resp = await fetch(`/jobs/${encodeURIComponent(jobId)}`);
            if (!resp.ok) throw new Error(resp.statusText);
            const data = await resp.json();
            const runs = data.runs || [];
            const summary = summarizeRuns(runs, targets);
            const c = summary.counts;

            const parts = [];
            if (c.queued) parts.push(`queued: ${c.queued}`);
            if (c.running) parts.push(`running: ${c.running}`);
            if (c.success) parts.push(`success: ${c.success}`);
            if (c.failed) parts.push(`failed: ${c.failed}`);

            const logsUrl = `/jobs/${encodeURIComponent(jobId)}/logs.zip`;

            if (statusEl) {
              statusEl.innerHTML = `Upgrading ${escapeHtml(String(pkgName))} — ${summary.done}/${summary.total} finished (${escapeHtml(parts.join(', '))}) (job_id: <code>${escapeHtml(jobId)}</code>) ` +
                `<a href="${logsUrl}" target="_blank" rel="noopener noreferrer">logs.zip</a>`;
            }

            if (summary.allDone) {
              if (statusEl) {
                const byAgent = new Map();
                (runs || []).forEach(r => byAgent.set(r.agent_id, r));

                const rowsHtml = targets.map(aid => {
                  const r = byAgent.get(aid) || { status: 'queued' };
                  const st = r.status || 'queued';
                  const stdoutUrl = `/jobs/${encodeURIComponent(jobId)}/runs/${encodeURIComponent(aid)}/stdout.txt`;
                  const stderrUrl = `/jobs/${encodeURIComponent(jobId)}/runs/${encodeURIComponent(aid)}/stderr.txt`;
                  return `<tr>` +
                    `<td><code>${escapeHtml(aid)}</code></td>` +
                    `<td>${escapeHtml(st)}</td>` +
                    `<td><a href="${stdoutUrl}" target="_blank" rel="noopener noreferrer">stdout</a></td>` +
                    `<td><a href="${stderrUrl}" target="_blank" rel="noopener noreferrer">stderr</a></td>` +
                    `</tr>`;
                }).join('');

                statusEl.innerHTML =
                  `Upgrade finished for ${escapeHtml(String(pkgName))}. success: ${c.success || 0}, failed: ${c.failed || 0}. ` +
                  `(job_id: <code>${escapeHtml(jobId)}</code>) ` +
                  `<a href="${logsUrl}" target="_blank" rel="noopener noreferrer">logs.zip</a>` +
                  `<details style="margin-top:6px"><summary>Per-host logs</summary>` +
                  `<div style="overflow:auto; max-height:220px; border:1px solid #333; padding:6px; margin-top:6px">` +
                  `<table style="width:100%; border-collapse:collapse">` +
                  `<thead><tr><th align="left">Host</th><th align="left">Status</th><th align="left">stdout</th><th align="left">stderr</th></tr></thead>` +
                  `<tbody>${rowsHtml}</tbody>` +
                  `</table>` +
                  `</div>` +
                  `</details>`;
              }
              return;
            }

            if (Date.now() - startedAt > 15000) intervalMs = 2000;
          } catch (e) {
            if (statusEl) statusEl.textContent = `Checking job status failed: ${e.message || e} (job_id: ${jobId})`;
          }

          await new Promise(r => setTimeout(r, intervalMs));
        }

        if (statusEl) statusEl.textContent = `Timed out waiting for upgrade to finish (job_id: ${jobId}).`;
      }

      async function verifyPackageVersions(targets, pkgName, vulnVersion, statusEl) {
        try {
          const resp = await fetch('/jobs/pkg-query', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ agent_ids: targets, packages: [pkgName] })
          });
          if (!resp.ok) {
            throw new Error(resp.statusText);
          }
          const out = await resp.json();
          const jobId = out.job_id;
          const queryTargets = out.targets || targets;

          // Poll query job until all done
          const startedAt = Date.now();
          const timeoutMs = 2 * 60 * 1000; // 2 minutes
          let intervalMs = 500;

          while (Date.now() - startedAt < timeoutMs) {
            const s = await fetch(`/jobs/${encodeURIComponent(jobId)}`);
            if (!s.ok) throw new Error(s.statusText);
            const data = await s.json();
            const runs = data.runs || [];

            const byAgent = new Map();
            runs.forEach(r => byAgent.set(r.agent_id, r));

            const done = queryTargets.filter(aid => {
              const r = byAgent.get(aid);
              return r && (r.status === 'success' || r.status === 'failed');
            }).length;

            if (statusEl) statusEl.textContent = `Verifying ${pkgName} version — ${done}/${queryTargets.length} hosts checked…`;

            if (done === queryTargets.length) {
              // Build per-host results
              const rows = queryTargets.map(aid => {
                const r = byAgent.get(aid);
                if (!r || r.status !== 'success' || !r.stdout) return { aid, ok: false, version: null };
                try {
                  const parsed = JSON.parse(r.stdout);
                  const pkg = (parsed.packages || [])[0];
                  return { aid, ok: true, version: (pkg && pkg.found) ? pkg.version : null };
                } catch {
                  return { aid, ok: false, version: null };
                }
              });

              // Store per-host verification results so the host list can show badges + version
              const resultsByAgentId = {};
              rows.forEach(x => {
                const found = !!(x.ok && x.version);
                let status = 'unknown';
                if (!x.ok) status = 'unknown';
                else if (!found) status = 'not-installed';
                else if (vulnVersion && matchesGlob(x.version, vulnVersion)) status = 'vulnerable';
                else if (vulnVersion && !matchesGlob(x.version, vulnVersion)) status = 'upgraded';
                else status = 'installed';
                resultsByAgentId[x.aid] = { ok: x.ok, found, version: x.version, status };
              });
              lastPkgVerification = { packageName: pkgName, vulnVersion: vulnVersion || '', resultsByAgentId };
              applyHostFilters();

              const stillVuln = (vulnVersion)
                ? rows.filter(x => x.ok && x.version && matchesGlob(x.version, vulnVersion)).map(x => x.aid)
                : [];
              const upgraded = (vulnVersion)
                ? rows.filter(x => x.ok && x.version && !matchesGlob(x.version, vulnVersion)).map(x => x.aid)
                : rows.filter(x => x.ok).map(x => x.aid);

              if (statusEl) {
                if (vulnVersion) {
                  statusEl.textContent =
                    `Verified ${pkgName}. Upgraded: ${upgraded.length}/${rows.length}. Still vulnerable (= ${vulnVersion}): ${stillVuln.length}.`;
                } else {
                  statusEl.textContent = `Verified ${pkgName} installed versions for ${rows.length} host(s). (Provide vulnerable version to auto-classify).`;
                }
              }
              return;
            }

            await new Promise(r => setTimeout(r, intervalMs));
            if (Date.now() - startedAt > 10000) intervalMs = 1000;
          }

          if (statusEl) statusEl.textContent = `Timed out verifying installed version of ${pkgName}.`;
        } catch (e) {
          if (statusEl) statusEl.textContent = `Verification failed: ${e.message || e}`;
        }
      }

      upgradeBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        upgradeSelected();
      });

      // Update upgrade controls when inputs change (also reset verification badges)
      pkgEl?.addEventListener('input', () => {
        lastPkgVerification = null;
        updateUpgradeControlsFn();
        applyHostFilters();
      });
      cveEl?.addEventListener('input', () => {
        lastPkgVerification = null;
        updateUpgradeControlsFn();
        applyHostFilters();
      });
      updateUpgradeControlsFn();
    }

    async function loadUsers(agentId) {
      const usersList = document.getElementById('users-list');
      usersList.innerHTML = '<div class="loading">Loading users...</div>';

      try {
        const response = await fetch(`/hosts/${agentId}/users`);
        if (!response.ok) {
          // Try to get error details from JSON response
          let errorMsg = response.statusText;
          try {
            const errorData = await response.json();
            errorMsg = errorData.detail || errorData.message || response.statusText;
          } catch {
            // If JSON parsing fails, use statusText
            errorMsg = response.statusText;
          }
          throw new Error(`Failed to load users: ${errorMsg}`);
        }
        const data = await response.json();

        if (!data.users || data.users.length === 0) {
          usersList.innerHTML = '<div class="empty-state">No users found</div>';
          return;
        }

        usersList.innerHTML = data.users.map(user => {
          const isNew = !!user.is_new;
          const canLockUsers = !!currentPermissions.can_lock_users;
          const isRoot = user.username === 'root';
          const disabledReason = !canLockUsers
            ? 'Admin access required'
            : isRoot
              ? 'Cannot lock root account'
              : '';
          return `
          <div class="user-card ${isNew ? 'new-user' : ''}" data-username="${escapeHtml(user.username)}">
            <div class="user-info">
              <div class="user-name"><a href="#" class="user-name-link" data-username="${escapeHtml(user.username)}" style="text-decoration:underline;">${escapeHtml(user.username)}</a>${isNew ? '<span class="new-user-badge">NEW</span>' : ''}</div>
              <div class="user-details">
                UID: ${escapeHtml(user.uid)} | GID: ${escapeHtml(user.gid)} | Shell: ${escapeHtml(user.shell || 'N/A')}${user.home ? ` | Home: ${escapeHtml(user.home)}` : ''}
              </div>
              <div style="margin-top: 0.5rem;">
                <span class="sudo-badge ${user.has_sudo ? 'yes' : 'no'}">
                  ${user.has_sudo ? '✓ Has Sudo' : '✗ No Sudo'}
                </span>
                ${user.is_locked ? '<span class="sudo-badge no" style="margin-left: 0.5rem;">🔒 Locked</span>' : ''}
              </div>
            </div>
            <div class="service-actions">
              <button class="btn ${user.is_locked ? 'btn-success' : 'btn-warning'}"
                data-user-action="${user.is_locked ? 'unlock' : 'lock'}"
                data-username="${escapeHtml(user.username)}"
                ${(isRoot || !canLockUsers) ? `disabled title="${disabledReason}"` : ''}>
                ${user.is_locked ? 'Unlock' : 'Lock'}
              </button>
            </div>
          </div>
        `;
        }).join('');

        usersList.querySelectorAll('a.user-name-link').forEach(a => {
          a.addEventListener('click', (e) => {
            e.preventDefault();
            const username = a.getAttribute('data-username') || '';
            if (!username) return;
            openUserModal(agentId, username);
          });
        });

        usersList.querySelectorAll('button[data-user-action][data-username]').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            const action = btn.getAttribute('data-user-action') || '';
            const username = btn.getAttribute('data-username') || '';
            if (!action || !username) return;
            controlUser(currentAgentId, username, action);
          });
        });
      } catch (error) {
        console.error('Error loading users:', error);
        usersList.innerHTML = `<div class="error">Error loading users: ${error.message}</div>`;
      }
    }

    async function loadAnsiblePlaybooks() {
      const selectEl = document.getElementById('ansible-playbook');
      const statusEl = document.getElementById('ansible-status');
      const runBtn = document.getElementById('ansible-open');
      if (!selectEl) return;
      try {
        if (statusEl) statusEl.textContent = 'Loading playbooks...';
        const resp = await fetch('/ansible/playbooks');
        if (!resp.ok) throw new Error(resp.statusText);
        const data = await resp.json();
        ansiblePlaybooks = Array.isArray(data) ? data : [];
        selectEl.innerHTML = '<option value="">Select playbook</option>' + ansiblePlaybooks.map(p => {
          const name = escapeHtml(p.name || '');
          return `<option value="${name}">${name}</option>`;
        }).join('');
        if (statusEl) statusEl.textContent = ansiblePlaybooks.length ? '' : 'No playbooks found.';
      } catch (e) {
        if (statusEl) statusEl.textContent = `Failed to load playbooks: ${e.message}`;
      } finally {
        if (runBtn) runBtn.disabled = !selectEl.value;
      }
    }

    function openAnsibleModal(playbookName) {
      const modal = document.getElementById('ansible-modal');
      const formEl = document.getElementById('ansible-modal-form');
      const metaEl = document.getElementById('ansible-modal-meta');
      const statusEl = document.getElementById('ansible-modal-status');
      const outputEl = document.getElementById('ansible-modal-output');
      const logEl = document.getElementById('ansible-modal-log');
      if (!modal || !formEl || !metaEl || !statusEl || !outputEl || !logEl) return;

      const playbook = ansiblePlaybooks.find(p => p.name === playbookName);
      if (!playbook) return;
      const targets = Array.from(selectedAgentIds);
      if (targets.length === 0 && currentAgentId) {
        targets.push(currentAgentId);
      }
      if (targets.length === 0) {
        const status = document.getElementById('ansible-status');
        if (status) status.textContent = 'Select at least one host.';
        return;
      }

      const prompts = Array.isArray(playbook.prompts) ? playbook.prompts : [];
      formEl.innerHTML = '';
      prompts.forEach(p => {
        const field = document.createElement('div');
        field.className = 'modal-field';
        const label = document.createElement('label');
        label.textContent = p.prompt || p.name;
        const input = document.createElement('input');
        input.type = p.private ? 'password' : 'text';
        input.setAttribute('data-var-name', p.name);
        // Auto-fill common target variables so the user doesn't have to type hosts manually.
        // Historically some playbooks used vars_prompt name "server"; newer ones use "target_hosts".
        if (p.name === 'server' || p.name === 'target_hosts') {
          input.value = targets.join(' ');
          // Keep it editable for target_hosts (power users may want to override with a group/all).
          if (p.name === 'server') input.readOnly = true;
        }
        field.appendChild(label);
        field.appendChild(input);
        formEl.appendChild(field);
      });
      if (prompts.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'modal-meta';
        empty.textContent = 'This playbook has no prompts.';
        formEl.appendChild(empty);
      }

      metaEl.textContent = `Playbook: ${playbook.name} · Targets: ${targets.length}`;
      statusEl.textContent = '';
      statusEl.classList.remove('error', 'success');
      logEl.textContent = '';
      outputEl.textContent = '';
      loadAnsibleLogs();
      modal.hidden = false;
      modal.classList.add('open');
      modal.setAttribute('aria-hidden', 'false');
    }

    function closeAnsibleModal() {
      const modal = document.getElementById('ansible-modal');
      if (!modal) return;
      modal.classList.remove('open');
      modal.setAttribute('aria-hidden', 'true');
      modal.hidden = true;
    }

    async function waitForJobDone(jobId, timeoutMs = 60000) {
      const started = Date.now();
      let last = null;
      while (Date.now() - started < timeoutMs) {
        const r = await fetch(`/jobs/${encodeURIComponent(jobId)}`, { credentials: 'include' });
        if (!r.ok) throw new Error(`Job status fetch failed (${r.status})`);
        last = await r.json();
        if (last && last.done) return last;
        await new Promise(res => setTimeout(res, 1500));
      }
      return last || { job_id: jobId, done: false, runs: [] };
    }

    function openSshKeyDeployApprovalModal(it) {
      const modal = document.getElementById('sshkey-approval-modal');
      const metaEl = document.getElementById('sshkey-approval-modal-meta');
      const targetsEl = document.getElementById('sshkey-approval-modal-targets');
      const stdoutBtn = document.getElementById('sshkey-approval-modal-download-stdout');
      const stderrBtn = document.getElementById('sshkey-approval-modal-download-stderr');
      const zipBtn = document.getElementById('sshkey-approval-modal-download-zip');
      if (!modal || !metaEl || !targetsEl) return;

      const targets = it.targets || (it.agent_ids || []).map(aid => ({ agent_id: String(aid), hostname: String(aid) }));
      const names = targets.map(t => t.hostname || t.agent_id).filter(Boolean);

      const keyShort = (String(it.key_id||'')).slice(0,8);
      const keyName = String(it.key_name || '').trim();
      const keyLabel = keyName ? `${keyName} (${keyShort})` : keyShort;
      let meta = `Requested by: ${it.user_name || it.user_id} · Key: ${keyLabel} · Created: ${formatShortTime(it.created_at)}`;
      if (it.job_id || it.jobId) meta += ` · Job: ${String(it.job_id || it.jobId).slice(0,8)}`;
      metaEl.textContent = meta;

      let body = names.length ? names.join('\n') : '(no targets)';
      if (it.job) {
        const runs = Array.isArray(it.job.runs) ? it.job.runs : [];
        const lines = runs.map(r => `- ${r.agent_id}: ${r.status}${r.exit_code != null ? ` (exit ${r.exit_code})` : ''}${r.error ? ` — ${r.error}` : ''}`);
        body += `\n\nJob result:\n${lines.join('\n') || '(no runs)'}`;
      }
      const jobId = String(it.job_id || it.jobId || '');
      const firstAgentId = (targets && targets.length) ? String(targets[0].agent_id || '') : '';

      // Wire up download buttons
      if (stdoutBtn) {
        if (jobId && firstAgentId) {
          stdoutBtn.href = `/jobs/${encodeURIComponent(jobId)}/runs/${encodeURIComponent(firstAgentId)}/stdout.txt`;
          stdoutBtn.style.display = 'inline-flex';
        } else {
          stdoutBtn.style.display = 'none';
        }
      }
      if (stderrBtn) {
        if (jobId && firstAgentId) {
          stderrBtn.href = `/jobs/${encodeURIComponent(jobId)}/runs/${encodeURIComponent(firstAgentId)}/stderr.txt`;
          stderrBtn.style.display = 'inline-flex';
        } else {
          stderrBtn.style.display = 'none';
        }
      }
      if (zipBtn) {
        if (jobId) {
          zipBtn.href = `/jobs/${encodeURIComponent(jobId)}/logs.zip`;
          zipBtn.style.display = 'inline-flex';
        } else {
          zipBtn.style.display = 'none';
        }
      }

      if (jobId) {
        body += `\n\nDownload logs: /jobs/${jobId}/logs.zip`;
      }
      targetsEl.textContent = body;

      modal.hidden = false;
      modal.classList.add('open');
      modal.setAttribute('aria-hidden', 'false');
    }

    async function openUserModal(agentId, username) {
      const modal = document.getElementById('user-modal');
      const metaEl = document.getElementById('user-modal-meta');
      const outEl = document.getElementById('user-modal-output');
      if (!modal || !metaEl || !outEl) return;

      const safe = (v) => escapeHtml(v == null ? '' : String(v));
      const kv = (k, v) => `<div class="kv-row"><strong>${safe(k)}:</strong> <code>${safe(v || '')}</code></div>`;

      outEl.innerHTML = '<div class="loading">Loading…</div>';
      metaEl.textContent = `Host: ${agentId}`;

      try {
        const r = await fetch(`/hosts/${encodeURIComponent(agentId)}/users/${encodeURIComponent(username)}`, { credentials: 'include' });
        const raw = await r.text();
        if (!r.ok) throw new Error(raw || `user details failed (${r.status})`);
        let d = null;
        try { d = raw ? JSON.parse(raw) : null; } catch { }
        const info = (d && d.user) ? d.user : d;

        outEl.innerHTML = [
          kv('Username', info.username),
          kv('UID', info.uid),
          kv('GID', info.gid),
          kv('Home', info.home),
          kv('Shell', info.shell),
          kv('Groups', info.groups),
          kv('Locked', info.locked),
          kv('Has sudo', info.has_sudo),
          kv('Sudo rules', info.sudo_rules),
          kv('Password status', info.password_status),
          kv('Last login', info.last_login),
        ].join('');
      } catch (e) {
        outEl.innerHTML = `<div class="error">${safe(e.message || String(e))}</div>`;
      }

      modal.hidden = false;
      modal.classList.add('open');
      modal.setAttribute('aria-hidden', 'false');
      const titleEl = document.getElementById('user-modal-title');
      if (titleEl) titleEl.textContent = `User details: ${username}`;
    }

    function closeUserModal() {
      const modal = document.getElementById('user-modal');
      if (!modal) return;
      modal.classList.remove('open');
      modal.setAttribute('aria-hidden', 'true');
      modal.hidden = true;
    }

    async function openServiceModal(agentId, serviceName) {
      const modal = document.getElementById('service-modal');
      const metaEl = document.getElementById('service-modal-meta');
      const outEl = document.getElementById('service-modal-output');
      if (!modal || !metaEl || !outEl) return;

      const safe = (v) => escapeHtml(v == null ? '' : String(v));
      const kv = (k, v) => `<div class="kv-row"><strong>${safe(k)}:</strong> <code>${safe(v || '')}</code></div>`;

      outEl.innerHTML = '<div class="loading">Loading…</div>';
      metaEl.textContent = `Host: ${agentId}`;

      try {
        const r = await fetch(`/hosts/${encodeURIComponent(agentId)}/services/${encodeURIComponent(serviceName)}`, { credentials: 'include' });
        const raw = await r.text();
        if (!r.ok) throw new Error(raw || `service details failed (${r.status})`);
        let d = null;
        try { d = raw ? JSON.parse(raw) : null; } catch { }
        const info = (d && d.service) ? d.service : d;

        const mem = info && (info.memory_current_human || info.memory_current);

        outEl.innerHTML = [
          kv('Path', info.fragment_path),
          kv('Memory usage', mem),
          kv('Requires', info.requires),
          kv('Wants', info.wants),
          kv('WantedBy', info.wanted_by),
          kv('ConsistsOf', info.consists_of),
          kv('Conflicts', info.conflicts),
          kv('Before', info.before),
          kv('After', info.after),
        ].join('');
      } catch (e) {
        outEl.innerHTML = `<div class="error">${safe(e.message || String(e))}</div>`;
      }

      modal.hidden = false;
      modal.classList.add('open');
      modal.setAttribute('aria-hidden', 'false');
      const titleEl = document.getElementById('service-modal-title');
      if (titleEl) titleEl.textContent = `Service details: ${serviceName}`;
    }

    function closeServiceModal() {
      const modal = document.getElementById('service-modal');
      if (!modal) return;
      modal.classList.remove('open');
      modal.setAttribute('aria-hidden', 'true');
      modal.hidden = true;
    }

    async function openDiskModal(agentId) {
      const modal = document.getElementById('disk-modal');
      const metaEl = document.getElementById('disk-modal-meta');
      const outEl = document.getElementById('disk-modal-output');
      const refreshBtn = document.getElementById('disk-modal-refresh');
      if (!modal || !metaEl || !outEl) return;

      const pctToColor = (pct) => {
        const p = Math.max(0, Math.min(100, Number(pct) || 0));
        const hue = 120 - (120 * (p / 100)); // 120=green → 0=red
        return `hsl(${hue} 85% 45%)`;
      };

      const parseDf = (stdout, showVirtual = false) => {
        const lines = String(stdout || '').split(/\r?\n/).filter(Boolean);
        if (!lines.length) return [];
        const rows = [];
        for (let i = 1; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) continue;
          const parts = line.split(/\s+/);
          // Expected: source fstype size used avail pcent target
          if (parts.length < 7) continue;
          const [source, fstype, size, used, avail, pcent, ...rest] = parts;
          const target = rest.join(' ');
          const pctNum = Number(String(pcent).replace('%',''));

          const fstypeL = String(fstype || '').toLowerCase();
          const sourceL = String(source || '').toLowerCase();

          if (!showVirtual) {
            // Hide virtual/noise filesystems by default
            if (
              fstypeL === 'tmpfs' ||
              fstypeL === 'devtmpfs' ||
              fstypeL === 'overlay' ||
              fstypeL === 'squashfs' ||
              sourceL.startsWith('tmpfs') ||
              sourceL.startsWith('overlay') ||
              sourceL.startsWith('devtmpfs')
            ) {
              continue;
            }
          }

          rows.push({ source, fstype, size, used, avail, pcent, pctNum, target });
        }
        return rows;
      };

      let lastStdout = '';
      const virtualEl = document.getElementById('disk-modal-show-virtual');
      const getShowVirtual = () => !!(virtualEl && virtualEl.checked);

      const renderDfTable = (stdout) => {
        const rows = parseDf(stdout, getShowVirtual());
        if (!rows.length) {
          outEl.textContent = stdout || '(no output)';
          return;
        }
        const header = ['Filesystem','Type','Mounted','Used','Avail','Size','Use%'];
        const html = [];
        html.push(`<div style="overflow:auto;">
          <table class="process-table" style="min-width:860px;">
            <thead><tr>${header.map(h=>`<th>${escapeHtml(h)}</th>`).join('')}</tr></thead>
            <tbody>
              ${rows.map(r => {
                const barColor = pctToColor(r.pctNum);
                return `
                  <tr>
                    <td style="font-family:monospace;">${escapeHtml(r.source)}</td>
                    <td>${escapeHtml(r.fstype)}</td>
                    <td style="font-family:monospace;">${escapeHtml(r.target)}</td>
                    <td>${escapeHtml(r.used)}</td>
                    <td>${escapeHtml(r.avail)}</td>
                    <td>${escapeHtml(r.size)}</td>
                    <td style="min-width:140px;">
                      <div style="display:flex;align-items:center;gap:10px;">
                        <div style="flex:1;height:10px;background:rgba(148,163,184,.25);border-radius:999px;overflow:hidden;">
                          <div style="width:${Math.max(0,Math.min(100,r.pctNum||0))}%;height:100%;background:${barColor};"></div>
                        </div>
                        <div style="width:44px;text-align:right;font-variant-numeric:tabular-nums;">${escapeHtml(r.pcent)}</div>
                      </div>
                    </td>
                  </tr>`;
              }).join('')}
            </tbody>
          </table>
        </div>`);
        outEl.innerHTML = html.join('');
      };

      const load = async () => {
        outEl.textContent = 'Loading…';
        try {
          const r = await fetch(`/hosts/${encodeURIComponent(agentId)}/df`, { credentials: 'include' });
          const raw = await r.text();
          if (!r.ok) throw new Error(raw || `df failed (${r.status})`);
          let data = null;
          try { data = raw ? JSON.parse(raw) : null; } catch { }
          lastStdout = (data && data.stdout) ? data.stdout : raw;
          renderDfTable(lastStdout);
        } catch (e) {
          outEl.textContent = e.message || String(e);
        }
      };

      metaEl.textContent = `Host: ${agentId}`;
      refreshBtn && (refreshBtn.onclick = (e) => { e.preventDefault(); load(); });
      if (virtualEl) virtualEl.onchange = () => { renderDfTable(lastStdout); };
      await load();

      modal.hidden = false;
      modal.classList.add('open');
      modal.setAttribute('aria-hidden', 'false');
    }

    function closeDiskModal() {
      const modal = document.getElementById('disk-modal');
      if (!modal) return;
      modal.classList.remove('open');
      modal.setAttribute('aria-hidden', 'true');
      modal.hidden = true;
    }

    function closeSshKeyDeployApprovalModal() {
      const modal = document.getElementById('sshkey-approval-modal');
      if (!modal) return;
      modal.classList.remove('open');
      modal.setAttribute('aria-hidden', 'true');
      modal.hidden = true;
    }

    async function runAnsiblePlaybook() {
      const modal = document.getElementById('ansible-modal');
      const statusEl = document.getElementById('ansible-modal-status');
      const outputEl = document.getElementById('ansible-modal-output');
      const runBtn = document.getElementById('ansible-modal-run');
      const selectEl = document.getElementById('ansible-playbook');
      const formEl = document.getElementById('ansible-modal-form');
      const logEl = document.getElementById('ansible-modal-log');
      const logsStatusEl = document.getElementById('ansible-logs-status');
      const logsListEl = document.getElementById('ansible-logs-list');
      if (!modal || !statusEl || !outputEl || !runBtn || !selectEl || !formEl || !logEl) return;

      const playbookName = selectEl.value;
      const targets = Array.from(selectedAgentIds);
      if (targets.length === 0 && currentAgentId) {
        targets.push(currentAgentId);
      }
      if (!playbookName || targets.length === 0) {
        statusEl.textContent = 'Select a playbook and at least one host.';
        statusEl.classList.add('error');
        return;
      }

      const extraVars = {};
      Array.from(formEl.querySelectorAll('input[data-var-name]')).forEach(input => {
        const name = input.getAttribute('data-var-name');
        if (!name) return;
        extraVars[name] = input.value;
      });

      runBtn.disabled = true;
      statusEl.textContent = 'Running...';
      statusEl.classList.remove('error', 'success');
      logEl.textContent = '';
      if (logsStatusEl) logsStatusEl.textContent = '';
      if (logsListEl) logsListEl.innerHTML = '';
      outputEl.textContent = '';
      try {
        const resp = await fetch('/ansible/run', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ playbook: playbookName, agent_ids: targets, extra_vars: extraVars }),
        });
        let data = null;
        const rawText = await resp.text();
        if (rawText) {
          try {
            data = JSON.parse(rawText);
          } catch (_) { }
        }
        if (!resp.ok || !data?.ok) {
          statusEl.textContent = data?.stderr || data?.detail || rawText || 'Playbook failed.';
          statusEl.classList.add('error');
        } else {
          statusEl.textContent = 'Completed successfully.';
          statusEl.classList.add('success');
        }
        if (data?.log_name) {
          const safeName = escapeHtml(data.log_name);
          const href = `/ansible/logs/${encodeURIComponent(data.log_name)}`;
          logEl.innerHTML = `Log saved: <a href="${href}" target="_blank" rel="noopener">${safeName}</a>`;
        }
        const combined = [data?.stdout || '', data?.stderr || ''].filter(Boolean).join('\n');
        outputEl.textContent = combined || '(no output)';
      } catch (e) {
        statusEl.textContent = `Run failed: ${e.message}`;
        statusEl.classList.add('error');
      } finally {
        runBtn.disabled = false;
      }
    }

    async function loadAnsibleLogs() {
      const logsStatusEl = document.getElementById('ansible-logs-status');
      const logsListEl = document.getElementById('ansible-logs-list');
      if (!logsStatusEl || !logsListEl) return;
      logsStatusEl.textContent = 'Loading logs...';
      logsListEl.innerHTML = '';
      try {
        const resp = await fetch('/ansible/logs?limit=5');
        if (!resp.ok) throw new Error(resp.statusText);
        const data = await resp.json();
        if (!Array.isArray(data) || data.length === 0) {
          logsStatusEl.textContent = 'No logs found.';
          return;
        }
        logsStatusEl.textContent = `${data.length} log(s) (showing latest ${data.length})`;
        logsListEl.innerHTML = data.map(item => {
          const name = escapeHtml(item.name || '');
          const href = `/ansible/logs/${encodeURIComponent(item.name)}`;
          const mtime = escapeHtml((item.mtime || '').replace('T', ' ').replace('Z', ' UTC'));
          const size = typeof item.size === 'number' ? `${Math.round(item.size / 1024)} KB` : '';
          return `<div><a href="${href}" target="_blank" rel="noopener">${name}</a> · ${mtime} · ${size}</div>`;
        }).join('');
      } catch (e) {
        logsStatusEl.textContent = `Failed to load logs: ${e.message}`;
      }
    }

    function initAnsibleSection() {
      const selectEl = document.getElementById('ansible-playbook');
      const openBtn = document.getElementById('ansible-open');
      const refreshBtn = document.getElementById('ansible-refresh');
      const modalClose = document.getElementById('ansible-modal-close');
      const modal = document.getElementById('ansible-modal');
      const modalRun = document.getElementById('ansible-modal-run');
      const logsRefresh = document.getElementById('ansible-logs-refresh');
      const outputCopy = document.getElementById('ansible-output-copy');
      const outputEl = document.getElementById('ansible-modal-output');

      refreshBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        loadAnsiblePlaybooks();
      });

      selectEl?.addEventListener('change', () => {
        if (openBtn) openBtn.disabled = !selectEl.value;
      });

      openBtn?.addEventListener('click', (e) => {
        e.preventDefault();
        if (!selectEl || !selectEl.value) return;
        openAnsibleModal(selectEl.value);
      });

      logsRefresh?.addEventListener('click', (e) => {
        e.preventDefault();
        loadAnsibleLogs();
      });

      outputCopy?.addEventListener('click', async (e) => {
        e.preventDefault();
        if (!outputEl) return;
        const text = outputEl.textContent || '';
        if (!text) return;
        try {
          if (navigator.clipboard?.writeText) {
            await navigator.clipboard.writeText(text);
            return;
          }
        } catch (_) { }
        try {
          const ta = document.createElement('textarea');
          ta.value = text;
          ta.style.position = 'fixed';
          ta.style.left = '-9999px';
          document.body.appendChild(ta);
          ta.select();
          document.execCommand('copy');
          document.body.removeChild(ta);
        } catch (_) { }
      });

      modalClose?.addEventListener('click', (e) => {
        e.preventDefault();
        closeAnsibleModal();
      });

      modal?.addEventListener('click', (e) => {
        if (e.target === modal) closeAnsibleModal();
      });

      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') closeAnsibleModal();
      });

      modalRun?.addEventListener('click', (e) => {
        e.preventDefault();
        runAnsiblePlaybook();
      });

      loadAnsiblePlaybooks();
    }

    // Packages UI
    let packagesSearchQuery = '';
    let packagesSearchTimer = null;
    let currentPackageName = null;
    let selectedPackages = new Set();
    let packagesUpdatesOnly = false;
    let pkgInteractiveTerminal = false;

    function initPackagesSearch() {
      const el = document.getElementById('packages-search');
      const checkBtn = document.getElementById('packages-check-updates');
      const clearBtn = document.getElementById('packages-search-clear');
      const updatesOnlyEl = document.getElementById('packages-updates-only');
      const selectVisibleEl = document.getElementById('select-visible-packages');
      const interactiveEl = document.getElementById('pkg-interactive-terminal');
      const upgradeBtn = document.getElementById('pkg-upgrade-selected');
      const reinstallBtn = document.getElementById('pkg-reinstall-selected');
      const removeBtn = document.getElementById('pkg-remove-selected');
      const statusEl = document.getElementById('pkg-actions-status');
      if (!el) return;
      function syncClearVisibility() {
        if (clearBtn) {
          clearBtn.style.display = el.value ? 'inline-flex' : 'none';
        }
      }

      el.addEventListener('input', () => {
        packagesSearchQuery = el.value || '';
        syncClearVisibility();
        if (packagesSearchTimer) clearTimeout(packagesSearchTimer);
        packagesSearchTimer = setTimeout(() => {
          if (currentAgentId && document.getElementById('packages-tab')?.classList.contains('active')) {
            loadPackages(currentAgentId);
          }
        }, 250);
      });

      clearBtn?.addEventListener('click', () => {
        el.value = '';
        packagesSearchQuery = '';
        syncClearVisibility();
        if (packagesSearchTimer) clearTimeout(packagesSearchTimer);
        if (currentAgentId && document.getElementById('packages-tab')?.classList.contains('active')) {
          loadPackages(currentAgentId);
        }
      });

      syncClearVisibility();

      updatesOnlyEl?.addEventListener('change', () => {
        packagesUpdatesOnly = !!updatesOnlyEl.checked;
        // Clear selected package details if filters change (prevents stale info panel)
        currentPackageName = null;
        const infoEl = document.getElementById('package-info');
        if (infoEl) infoEl.innerHTML = '';
        // Keep selection but it may become hidden; user can "Select all visible" to reset.
        if (currentAgentId && document.getElementById('packages-tab')?.classList.contains('active')) {
          loadPackages(currentAgentId);
        }
      });

      interactiveEl?.addEventListener('change', () => {
        pkgInteractiveTerminal = !!interactiveEl.checked;
        if (statusEl && pkgInteractiveTerminal) {
          statusEl.textContent = 'Interactive mode: actions will open Terminal and run apt commands without -y.';
        } else if (statusEl && !selectedPackages.size) {
          statusEl.textContent = '';
        }
      });

      async function openTerminalAndRun(command) {
        if (!currentAgentId) return;
        showTerminal();
        // Wait for websocket to be ready then send command + newline
        const started = Date.now();
        while (Date.now() - started < 8000) {
          if (ws && ws.readyState === 1) {
            ws.send(new TextEncoder().encode(command + "\n"));
            return;
          }
          await new Promise(r => setTimeout(r, 150));
        }
        throw new Error('Terminal not connected yet');
      }

      function updatePkgActionControls(latestList = null) {
        const totalSelected = selectedPackages.size;
        if (reinstallBtn) reinstallBtn.disabled = totalSelected === 0;
        if (removeBtn) removeBtn.disabled = totalSelected === 0;
        // Allow upgrade to run even if we haven't checked availability; apt-get --only-upgrade will no-op if none.
        if (upgradeBtn) upgradeBtn.disabled = totalSelected === 0;
        if (statusEl) statusEl.textContent = totalSelected ? `Selected: ${totalSelected} package(s). (Tip: click “Check updates” to see ↑ indicators)` : '';
      }

      // pollJob is defined globally

      async function doCheckUpdates(refresh, maxMs = 180000) {
        if (!currentAgentId) return;
        const resp = await fetch(`/hosts/${currentAgentId}/packages/check-updates?refresh=${refresh ? 'true' : 'false'}&wait=false`, { method: 'POST' });
        if (!resp.ok) {
          let msg = resp.statusText;
          try { const err = await resp.json(); msg = err.detail || err.message || msg; } catch { }
          throw new Error(msg);
        }
        const out = await resp.json();
        const jobId = out.job_id;
        await pollJob(jobId, statusEl, maxMs);
      }

      async function runPkgAction(action) {
        if (!currentAgentId) return;

        // CVE workflow: upgrade per-host affected packages across the selected affected hosts.
        // This keeps blast radius low and avoids forcing a global dist-upgrade.
        const cve = (document.getElementById('vuln-cve')?.value || '').trim().toUpperCase();
        const isCveMode = action === 'upgrade' && !!cve && !!lastCveCheck && lastCveCheck.cve === cve && selectedAgentIds && selectedAgentIds.size > 0;
        if (isCveMode) {
          const targets = Array.from(selectedAgentIds);
          const packagesByAgent = {};
          for (const aid of targets) {
            const r = lastCveCheck?.resultsByAgentId?.[aid];
            const pk = Array.isArray(r?.packages) ? r.packages.filter(Boolean) : [];
            if (pk.length) packagesByAgent[aid] = pk;
          }
          if (Object.keys(packagesByAgent).length === 0) {
            if (statusEl) statusEl.textContent = 'No affected packages found for selected hosts. Re-run CVE check.';
            return;
          }

          try {
            if (statusEl) statusEl.textContent = `Starting CVE-targeted upgrade on ${targets.length} host(s)…`;
            if (upgradeBtn) upgradeBtn.disabled = true;
            if (reinstallBtn) reinstallBtn.disabled = true;
            if (removeBtn) removeBtn.disabled = true;

            const resp = await fetch('/jobs/pkg-upgrade', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ agent_ids: targets, packages_by_agent: packagesByAgent })
            });
            if (!resp.ok) {
              let msg = resp.statusText;
              try { const err = await resp.json(); msg = err.detail || err.message || msg; } catch { }
              throw new Error(msg);
            }
            const out = await resp.json();
            const jobId = out.job_id;
            if (statusEl) statusEl.textContent = `Upgrade started (job_id: ${jobId}). Waiting…`;
            await pollJob(jobId, statusEl, 10 * 60 * 1000);
            if (statusEl) statusEl.textContent = `Upgrade finished. Re-run CVE check to confirm remediation.`;
            return;
          } catch (e) {
            if (statusEl) statusEl.textContent = `Error: ${e.message || e}`;
            return;
          }
        }

        const pkgs = Array.from(selectedPackages);
        if (!pkgs.length) return;

        // Interactive: run via Terminal instead of API job (allows dpkg/apt prompts)
        if (pkgInteractiveTerminal) {
          if (action === 'remove') {
            const ok = confirm(`Open Terminal and run interactive REMOVE for ${pkgs.length} package(s) on ${currentAgentId}?\n\n${pkgs.slice(0, 20).join(', ')}${pkgs.length > 20 ? '…' : ''}`);
            if (!ok) return;
          }
          try {
            const pkgArgs = pkgs.map(p => `'${String(p).replaceAll("'", "'\\''")}'`).join(' ');
            const cmd = action === 'upgrade'
              ? `sudo apt-get update && sudo apt-get install --only-upgrade ${pkgArgs}`
              : action === 'reinstall'
                ? `sudo apt-get update && sudo apt-get install --reinstall ${pkgArgs}`
                : `sudo apt-get remove ${pkgArgs}`;
            if (statusEl) statusEl.textContent = `Opening Terminal for interactive ${action}…`;
            // Prefer a real popup window so you can interact comfortably.
            const w = window.open(`/terminal?agent_id=${encodeURIComponent(currentAgentId)}&cmd=${encodeURIComponent(cmd)}`, '_blank', 'width=1100,height=750');
            if (w) {
              if (statusEl) statusEl.textContent = `Opened terminal window for interactive ${action}.`;
            } else {
              // Popups blocked → fall back to in-page terminal tab
              await openTerminalAndRun(cmd);
              if (statusEl) statusEl.textContent = `Terminal opened (in-page). Running: ${cmd}`;
            }
          } catch (e0) {
            if (statusEl) statusEl.textContent = `Interactive terminal error: ${e0.message || e0}`;
          }
          return;
        }

        if (action === 'remove') {
          const ok = confirm(`Remove ${pkgs.length} package(s) from ${currentAgentId}?\n\n${pkgs.slice(0, 20).join(', ')}${pkgs.length > 20 ? '…' : ''}`);
          if (!ok) return;
        }
        try {
          if (statusEl) statusEl.textContent = `Starting ${action} for ${pkgs.length} package(s)…`;
          if (upgradeBtn) upgradeBtn.disabled = true;
          if (reinstallBtn) reinstallBtn.disabled = true;
          if (removeBtn) removeBtn.disabled = true;
          const resp = await fetch(`/hosts/${currentAgentId}/packages/action`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ action, packages: pkgs })
          });
          if (!resp.ok) {
            let msg = resp.statusText;
            try { const err = await resp.json(); msg = err.detail || err.message || msg; } catch { }
            throw new Error(msg);
          }
          const out = await resp.json();
          const jobId = out.job_id;
          if (statusEl) statusEl.textContent = `${action} started (job_id: ${jobId}). Waiting…`;
          await pollJob(jobId, statusEl);
          if (statusEl) statusEl.textContent = `${action} finished. Refreshing update status…`;
          selectedPackages = new Set();
          if (selectVisibleEl) selectVisibleEl.checked = false;
          // After an upgrade/reinstall/remove, re-check update availability so "Updates only" view updates immediately.
          // Use refresh=false because upgrade already ran apt-get update, and we want a quick recompute.
          try {
            await doCheckUpdates(false, 120000);
          } catch (e3) {
            // If update check fails, still refresh the list.
            console.warn('Post-action update check failed:', e3);
          }
          if (statusEl) statusEl.textContent = `Refreshing package list…`;
          // When using "Updates only" view, the backend filter is based on cached inventory/update flags.
          // After an upgrade, refresh inventory so upgraded packages disappear from the updates-only list.
          if (action === 'upgrade' && packagesUpdatesOnly) {
            await refreshPackagesNow(currentAgentId);
          } else {
            await loadPackages(currentAgentId);
          }
        } catch (e) {
          if (statusEl) statusEl.textContent = `Error: ${e.message || e}`;
        }
      }

      upgradeBtn?.addEventListener('click', (e) => { e.preventDefault(); runPkgAction('upgrade'); });
      reinstallBtn?.addEventListener('click', (e) => { e.preventDefault(); runPkgAction('reinstall'); });
      removeBtn?.addEventListener('click', (e) => { e.preventDefault(); runPkgAction('remove'); });

      selectVisibleEl?.addEventListener('change', () => {
        if (selectVisibleEl.checked) {
          // select all visible package cards
          document.querySelectorAll('.package-checkbox[data-pkg]').forEach(cb => {
            const name = cb.getAttribute('data-pkg');
            if (!name) return;
            cb.checked = true;
            selectedPackages.add(name);
          });
        } else {
          document.querySelectorAll('.package-checkbox[data-pkg]').forEach(cb => { cb.checked = false; });
          selectedPackages = new Set();
        }
        updatePkgActionControls(window.__lastPackagesList || null);
      });

      checkBtn?.addEventListener('click', async (e) => {
        e.preventDefault();
        if (!currentAgentId) return;
        try {
          if (statusEl) statusEl.textContent = 'Checking updates… (this may take a bit)';
          await doCheckUpdates(true, 180000);
          if (statusEl) statusEl.textContent = 'Update check finished. Refreshing list…';
          await loadPackages(currentAgentId);
        } catch (e2) {
          if (statusEl) statusEl.textContent = `Update check error: ${e2.message || e2}`;
        }
      });

      // Expose for loadPackages to update control state after render
      window.__updatePkgActionControls = updatePkgActionControls;
    }

    async function loadPackages(agentId) {
      const listEl = document.getElementById('packages-list');
      const metaEl = document.getElementById('packages-meta');
      const infoEl = document.getElementById('package-info');
      if (!listEl || !metaEl || !infoEl) return;

      listEl.innerHTML = '<div class="loading">Loading packages...</div>';
      metaEl.textContent = '';

      try {
        const q = (packagesSearchQuery || '').trim();
        const params = new URLSearchParams();
        if (q) params.set('search', q);
        if (packagesUpdatesOnly) params.set('upgradable_only', 'true');
        params.set('limit', '500');
        const resp = await fetch(`/hosts/${agentId}/packages?${params.toString()}`);
        if (!resp.ok) {
          let msg = resp.statusText;
          try { const err = await resp.json(); msg = err.detail || err.message || msg; } catch { }
          throw new Error(msg);
        }
        const data = await resp.json();
        const pkgs = data.packages || [];
        const total = data.total ?? pkgs.length;
        const collectedAt = data.collected_at;
        const updatesCheckedAt = data.updates_checked_at;
        window.__lastPackagesList = pkgs;

        // If we're in CVE mode, pre-select affected packages for this host.
        try {
          const cve = (document.getElementById('vuln-cve')?.value || '').trim().toUpperCase();
          if (cve && lastCveCheck && lastCveCheck.cve === cve) {
            const r = lastCveCheck?.resultsByAgentId?.[agentId];
            const pkgs2 = Array.isArray(r?.packages) ? r.packages : [];
            // Only auto-apply if user hasn't manually selected anything yet.
            if (pkgs2.length && selectedPackages.size === 0) {
              selectedPackages = new Set(pkgs2);
            }
          }
        } catch { }

        metaEl.textContent = `Showing ${pkgs.length} of ${total}${collectedAt ? ` (inventory: ${new Date(collectedAt).toLocaleString()})` : ''}${updatesCheckedAt ? ` • updates checked: ${new Date(updatesCheckedAt).toLocaleString()}` : ''}.`;

        // If the currently selected package is no longer visible under the current filters, clear the info panel.
        if (currentPackageName && !pkgs.some(p => p && p.name === currentPackageName)) {
          currentPackageName = null;
          infoEl.innerHTML = '';
        }

        if (!pkgs.length) {
          listEl.innerHTML = '<div class="empty-state">No packages match your search</div>';
          return;
        }

        listEl.innerHTML = pkgs.map(p => {
          const name = escapeHtml(p.name || '');
          const version = escapeHtml(p.version || '');
          const arch = escapeHtml(p.arch || '');
          const isActive = currentPackageName === p.name;
          const up = !!p.update_available;
          const cand = p.candidate_version ? escapeHtml(p.candidate_version) : '';
          const checked = selectedPackages.has(p.name);
          return `
            <div class="package-card ${isActive ? 'active' : ''} ${up ? 'upgradable' : ''}" data-pkg="${name}">
              <div class="package-select-wrap">
                <input class="package-checkbox" type="checkbox" data-pkg="${name}" ${checked ? 'checked' : ''} />
                <div style="min-width:0;">
                  <div class="package-name">${name}${up ? `<span class="pkg-up-arrow">↑</span>` : ''}</div>
                  <div class="package-meta">${version}${cand ? ` → ${cand}` : ''}${arch ? ` • ${arch}` : ''}</div>
                </div>
              </div>
            </div>
          `;
        }).join('');

        document.querySelectorAll('.package-card[data-pkg]').forEach(card => {
          card.addEventListener('click', (e) => {
            e.preventDefault();
            const pkgName = card.getAttribute('data-pkg');
            if (!pkgName) return;
            void selectPackage(pkgName);
          });
        });

        // Checkbox wiring (prevent card click)
        document.querySelectorAll('.package-checkbox[data-pkg]').forEach(cb => {
          cb.addEventListener('click', (e) => e.stopPropagation());
          cb.addEventListener('change', (e) => {
            e.stopPropagation();
            const name = cb.getAttribute('data-pkg');
            if (!name) return;
            if (cb.checked) selectedPackages.add(name);
            else selectedPackages.delete(name);
            if (window.__updatePkgActionControls) window.__updatePkgActionControls(pkgs);
          });
        });

        if (window.__updatePkgActionControls) window.__updatePkgActionControls(pkgs);
      } catch (e) {
        listEl.innerHTML = `<div class="error">Error loading packages: ${escapeHtml(e.message || String(e))}</div>`;
      }
    }

    async function refreshPackagesNow(agentId) {
      const statusEl = document.getElementById('pkg-actions-status');
      try {
        if (statusEl) statusEl.textContent = 'Refreshing package inventory…';
        const resp = await fetch(`/hosts/${encodeURIComponent(agentId)}/packages/refresh?wait=false`, { method: 'POST' });
        if (!resp.ok) {
          let msg = resp.statusText;
          try { const err = await resp.json(); msg = err.detail || err.message || msg; } catch { }
          throw new Error(msg);
        }
        const out = await resp.json();
        const jobId = out.job_id;
        if (!jobId) throw new Error('No job_id returned');
        // Reuse packages pollJob helper (defined inside initPackagesSearch) via a local polling loop
        const started = Date.now();
        let interval = 600;
        while (Date.now() - started < 120000) {
          const jr = await fetch(`/jobs/${jobId}`);
          if (!jr.ok) throw new Error(jr.statusText);
          const jd = await jr.json();
          const done = (jd && jd.done === true) || (Array.isArray(jd?.runs) && jd.runs.length > 0 && jd.runs.every(r => r.status === 'success' || r.status === 'failed'));
          if (done) break;
          await new Promise(r => setTimeout(r, interval));
          if (interval < 1500) interval += 150;
        }
        if (document.getElementById('packages-tab')?.classList.contains('active') && currentAgentId === agentId) {
          if (statusEl) statusEl.textContent = 'Package inventory refreshed.';
          await loadPackages(agentId);
        }
      } catch (e) {
        if (statusEl) statusEl.textContent = `Package refresh failed: ${e.message || e}`;
      }
    }

    function escapeJs(s) {
      return String(s).replaceAll('\\', '\\\\').replaceAll("'", "\\'").replaceAll("\n", "\\n");
    }

    async function selectPackage(pkgName) {
      if (!currentAgentId) return;
      currentPackageName = pkgName;
      // Highlight selected in list
      document.querySelectorAll('.package-card').forEach(el => {
        el.classList.toggle('active', el.getAttribute('data-pkg') === pkgName);
      });
      await loadPackageInfo(currentAgentId, pkgName);
    }

    async function loadPackageInfo(agentId, pkgName) {
      const infoEl = document.getElementById('package-info');
      if (!infoEl) return;
      infoEl.innerHTML = `<div class="loading">Loading package info for <code>${escapeHtml(pkgName)}</code>…</div>`;
      try {
        const resp = await fetch(`/hosts/${agentId}/packages/${encodeURIComponent(pkgName)}/info`);
        if (!resp.ok) {
          let msg = resp.statusText;
          try { const err = await resp.json(); msg = err.detail || err.message || msg; } catch { }
          throw new Error(msg);
        }
        const data = await resp.json();
        const name = escapeHtml(data.name || pkgName);
        const installed = data.installed_version ? `<code>${escapeHtml(data.installed_version)}</code>` : '<code>not installed</code>';
        const candidate = data.candidate_version ? `<code>${escapeHtml(data.candidate_version)}</code>` : '<code>n/a</code>';
        const summary = escapeHtml(data.summary || '');
        const desc = escapeHtml(data.description || '');

        infoEl.innerHTML = `
          <div class="package-info-title">${name}</div>
          ${summary ? `<div class="package-meta">${summary}</div>` : ''}
          <div class="kv-row"><strong>Installed:</strong> ${installed}</div>
          <div class="kv-row"><strong>Candidate:</strong> ${candidate}</div>
          ${data.section ? `<div class="kv-row"><strong>Section:</strong> <code>${escapeHtml(data.section)}</code></div>` : ''}
          ${data.priority ? `<div class="kv-row"><strong>Priority:</strong> <code>${escapeHtml(data.priority)}</code></div>` : ''}
          ${data.maintainer ? `<div class="kv-row"><strong>Maintainer:</strong> ${escapeHtml(data.maintainer)}</div>` : ''}
          ${data.homepage ? `<div class="kv-row"><strong>Homepage:</strong> <a href="${escapeHtml(data.homepage)}" target="_blank" rel="noopener noreferrer" style="text-decoration:underline;">${escapeHtml(data.homepage)}</a></div>` : ''}
          ${desc ? `<div style="margin-top:0.75rem;"><strong>Description</strong><div class="pkg-raw">${desc}</div></div>` : ''}
        `;
      } catch (e) {
        infoEl.innerHTML = `<div class="error">Error loading package info: ${escapeHtml(e.message || String(e))}</div>`;
      }
    }

    async function loadServices(agentId) {
      const servicesList = document.getElementById('services-list');
      servicesList.innerHTML = '<div class="loading">Loading services...</div>';

      try {
        const response = await fetch(`/hosts/${agentId}/services`);
        if (!response.ok) {
          // Try to get error details from JSON response
          let errorMsg = response.statusText;
          try {
            const errorData = await response.json();
            errorMsg = errorData.detail || errorData.message || response.statusText;
          } catch {
            // If JSON parsing fails, use statusText
            errorMsg = response.statusText;
          }
          throw new Error(`Failed to load services: ${errorMsg}`);
        }
        const data = await response.json();

        if (!data.services || data.services.length === 0) {
          servicesList.innerHTML = '<div class="empty-state">No services found</div>';
          return;
        }

        servicesList.innerHTML = data.services.map(service => {
          const statusClass = service.status === 'active' ? 'active' :
            service.status === 'failed' ? 'failed' : 'inactive';
          const enabledBadge = service.enabled ? '<span class="sudo-badge yes" style="margin-left: 0.5rem;">✓ Enabled</span>' : '<span class="sudo-badge no" style="margin-left: 0.5rem;">✗ Disabled</span>';
          return `
            <div class="service-card" data-service-name="${escapeHtml(service.name)}">
              <div class="service-info">
                <div class="service-name"><a href="#" class="service-name-link" data-service="${escapeHtml(service.name)}" style="text-decoration:underline;">${escapeHtml(service.name)}</a></div>
                <div class="service-details">
                  <span class="service-status ${statusClass}">${escapeHtml(service.status)}</span>
                  ${enabledBadge}
                  ${escapeHtml(service.description || '')}
                </div>
              </div>
              <div class="service-actions">
                <button class="btn btn-success" data-service-action="start" data-service-name="${escapeHtml(service.name)}"
                  ${service.status === 'active' ? 'disabled' : ''}>Start</button>
                <button class="btn btn-warning" data-service-action="restart" data-service-name="${escapeHtml(service.name)}">Restart</button>
                <button class="btn btn-danger" data-service-action="stop" data-service-name="${escapeHtml(service.name)}"
                  ${service.status !== 'active' ? 'disabled' : ''}>Stop</button>
                <button class="btn ${service.enabled ? 'btn-danger' : 'btn-success'}" data-service-action="${service.enabled ? 'disable' : 'enable'}" data-service-name="${escapeHtml(service.name)}">
                  ${service.enabled ? 'Disable' : 'Enable'}
                </button>
              </div>
            </div>
          `;
        }).join('');

        // Make service names clickable for details.
        servicesList.querySelectorAll('a.service-name-link').forEach(a => {
          a.addEventListener('click', (e) => {
            e.preventDefault();
            const name = a.getAttribute('data-service') || '';
            if (!name) return;
            openServiceModal(agentId, name);
          });
        });

        servicesList.querySelectorAll('button[data-service-action][data-service-name]').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            const action = btn.getAttribute('data-service-action') || '';
            const serviceName = btn.getAttribute('data-service-name') || '';
            if (!action || !serviceName) return;
            controlService(agentId, serviceName, action);
          });
        });
      } catch (error) {
        console.error('Error loading services:', error);
        servicesList.innerHTML = `<div class="error">Error loading services: ${error.message}</div>`;
      }
    }

    // Check if any service is in activating or deactivating state
    function hasActivatingServices() {
      const serviceCards = document.querySelectorAll('.service-card');
      for (const card of serviceCards) {
        const statusBadge = card.querySelector('.service-status');
        if (statusBadge) {
          const status = statusBadge.textContent.toLowerCase().trim();
          // Check for actual status values or loading states
          if (status === 'activating' || status === 'deactivating' ||
            status.includes('starting') || status.includes('stopping') ||
            status.includes('restarting') || status.includes('enabling') ||
            status.includes('disabling')) {
            return true;
          }
        }
      }
      return false;
    }

    // Poll in background until services stabilize, then reload
    // This function waits without constantly reloading the UI
    async function waitForServicesToStabilize(agentId, targetServiceName = null) {
      const maxWaitTime = 120000; // Maximum 120 seconds (2 minutes)
      const pollInterval = 3000; // Check every 3 seconds (less frequent to avoid UI flicker)
      const startTime = Date.now();
      let pollCount = 0;
      let lastStatus = null;

      console.log(`Starting background polling for services to stabilize${targetServiceName ? ` (waiting for ${targetServiceName})` : ''}...`);

      while (Date.now() - startTime < maxWaitTime) {
        pollCount++;

        try {
          // Fetch services status without updating the UI
          const response = await fetch(`/hosts/${agentId}/services`);
          if (!response.ok) {
            throw new Error(`Failed to fetch services: ${response.statusText}`);
          }

          const data = await response.json();
          const services = data.services || [];

          // If we're waiting for a specific service, check its status
          if (targetServiceName) {
            const targetService = services.find(s => s.name === targetServiceName);
            if (targetService) {
              const currentStatus = targetService.status;

              // Log status changes
              if (currentStatus !== lastStatus) {
                console.log(`Service ${targetServiceName} status: ${lastStatus || 'unknown'} -> ${currentStatus}`);
                lastStatus = currentStatus;
              }

              // If service is active or failed, we're done
              if (currentStatus === 'active' || currentStatus === 'failed') {
                console.log(`Service ${targetServiceName} is now ${currentStatus}, reloading services list...`);
                await loadServices(agentId);
                return;
              }

              // If service is still activating/deactivating, continue waiting
              if (currentStatus === 'activating' || currentStatus === 'deactivating' ||
                currentStatus === 'inactive') {
                // Continue polling
                await new Promise(resolve => setTimeout(resolve, pollInterval));
                continue;
              }
            } else {
              // Service not found in list, might have been removed or name mismatch
              console.warn(`Service ${targetServiceName} not found in services list`);
            }
          }

          // Check if any services are still activating/deactivating
          const hasActivating = services.some(s =>
            s.status === 'activating' || s.status === 'deactivating'
          );

          if (!hasActivating) {
            // No services are activating, we're done
            console.log(`All services stabilized after ${pollCount} check(s), reloading...`);
            await loadServices(agentId);
            return;
          }

          // Log periodically (every 10 checks = ~30 seconds)
          if (pollCount % 10 === 0) {
            console.log(`Still waiting for services to stabilize... (${pollCount * pollInterval / 1000}s elapsed)`);
          }
        } catch (error) {
          console.error('Error checking services status during polling:', error);
          // Continue polling even if one check fails
        }

        await new Promise(resolve => setTimeout(resolve, pollInterval));
      }

      // Timeout reached, reload anyway to get current state
      console.log(`Timeout reached after ${maxWaitTime / 1000} seconds, reloading services...`);
      await loadServices(agentId);
    }

    async function controlService(agentId, serviceName, action) {
      // Find the service card using data attribute
      const targetCard = document.querySelector(`.service-card[data-service-name="${serviceName}"]`);

      // Disable all buttons in this service card
      if (targetCard) {
        const buttons = targetCard.querySelectorAll('.btn');
        buttons.forEach(btn => {
          btn.disabled = true;
          btn.style.opacity = '0.6';
          btn.style.cursor = 'wait';
        });

        // Show loading state
        const statusBadge = targetCard.querySelector('.service-status');
        if (statusBadge) {
          const actionText = action === 'start' ? 'Starting' :
            action === 'stop' ? 'Stopping' :
              action === 'restart' ? 'Restarting' :
                action === 'enable' ? 'Enabling' :
                  action === 'disable' ? 'Disabling' : action;
          statusBadge.textContent = actionText + '...';
          statusBadge.className = 'service-status';
        }
      }

      try {
        // Create AbortController for timeout
        // Some services may take longer, so allow up to 40 seconds (with buffer for server timeout)
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 40000); // 40 second timeout

        const response = await fetch(`/hosts/${agentId}/services/${encodeURIComponent(serviceName)}/${action}`, {
          method: 'POST',
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          let errorMsg = `Failed to ${action} service`;
          try {
            const error = await response.json();
            errorMsg = error.detail || error.message || errorMsg;
          } catch {
            errorMsg = response.statusText || errorMsg;
          }
          throw new Error(errorMsg);
        }

        const result = await response.json();
        console.log('Service control result:', result);
        const actionLabel =
          action === 'start' ? 'Started' :
            action === 'stop' ? 'Stopped' :
              action === 'restart' ? 'Restarted' :
                action === 'enable' ? 'Enabled' :
                  action === 'disable' ? 'Disabled' : action;
        showToast(`${actionLabel} ${serviceName}`, 'success');

        // Wait a moment for the service status to update on the server
        await new Promise(resolve => setTimeout(resolve, 1000));

        // Poll in background until service stabilizes, then reload
        // Pass the service name so we can specifically wait for it to become active
        await waitForServicesToStabilize(agentId, serviceName);
      } catch (error) {
        console.error('Error controlling service:', error);

        // Re-enable buttons on error
        if (targetCard) {
          const buttons = targetCard.querySelectorAll('.btn');
          buttons.forEach(btn => {
            btn.disabled = false;
            btn.style.opacity = '1';
            btn.style.cursor = 'pointer';
          });
        }

        // Show error message
        let errorMsg = error.message;
        if (error.name === 'AbortError') {
          errorMsg = 'Operation timed out. The service may still be processing. Refreshing status...';
        }

        showToast(errorMsg, 'error');

        // Poll and reload after error/timeout once services stabilize
        // Still wait for the service to stabilize even after error
        await waitForServicesToStabilize(agentId, serviceName);
      }
    }

    // Make controlService available globally
    window.controlService = controlService;

    async function controlUser(agentId, username, action) {
      if (!currentPermissions.can_lock_users) {
        showToast('Admin access required to lock or unlock users.', 'error');
        return;
      }
      // Find the user card using data attribute
      const targetCard = document.querySelector(`.user-card[data-username="${username}"]`);

      // Disable button during operation
      if (targetCard) {
        const button = targetCard.querySelector('.btn');
        if (button) {
          button.disabled = true;
          button.style.opacity = '0.6';
          button.style.cursor = 'wait';
          button.textContent = action === 'lock' ? 'Locking...' : 'Unlocking...';
        }
      }

      try {
        // Create AbortController for timeout
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 20000); // 20 second timeout

        const response = await fetch(`/hosts/${agentId}/users/${encodeURIComponent(username)}/${action}`, {
          method: 'POST',
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          let errorMsg = `Failed to ${action} user`;
          try {
            const error = await response.json();
            errorMsg = error.detail || error.message || errorMsg;
          } catch {
            errorMsg = response.statusText || errorMsg;
          }
          throw new Error(errorMsg);
        }

        const result = await response.json();
        console.log('User control result:', result);
        showToast(`${action === 'lock' ? 'Locked' : 'Unlocked'} ${username}`, 'success');

        // Wait a moment for the user status to update on the server
        await new Promise(resolve => setTimeout(resolve, 500));

        // Reload users to get updated status
        await loadUsers(agentId);
      } catch (error) {
        console.error('Error controlling user:', error);

        // Re-enable button on error
        if (targetCard) {
          const button = targetCard.querySelector('.btn');
          if (button) {
            button.disabled = false;
            button.style.opacity = '1';
            button.style.cursor = 'pointer';
            // Restore original button text - will be updated when we reload
            button.textContent = 'Loading...';
          }
        }

        // Show error message
        let errorMsg = error.message;
        if (error.name === 'AbortError') {
          errorMsg = 'Operation timed out. The user status may still be updating. Refreshing...';
        }

        showToast(errorMsg, 'error');

        // Always reload to get accurate state, even on error/timeout
        await loadUsers(agentId);
      }
    }

    // Make controlUser available globally
    window.controlUser = controlUser;

    async function loadFleetOverview(forceLive = false) {
      const onlineEl = document.getElementById('kpi-online');
      const onlineDetailsEl = document.getElementById('kpi-online-details');
      const secEl = document.getElementById('kpi-sec');
      const secDetailsEl = document.getElementById('kpi-sec-details');
      const updEl = document.getElementById('kpi-upd');
      const updDetailsEl = document.getElementById('kpi-upd-details');
      const failEl = document.getElementById('kpi-fail');
      const freshEl = document.getElementById('kpi-fresh');
      const attentionEl = document.getElementById('overview-attention');

      try {
        const r = await fetch('/dashboard/summary', { credentials: 'include' });
        if (!r.ok) throw new Error(`dashboard summary failed (${r.status})`);
        const d = await r.json();

        const hostsTotal = d?.hosts?.total ?? 0;
        const hostsOnline = d?.hosts?.online ?? 0;
        const hostsOffline = d?.hosts?.offline ?? Math.max(0, hostsTotal - hostsOnline);
        const secHosts = d?.updates?.hosts_with_security_updates ?? 0;
        const secPkgs = d?.updates?.security_total ?? 0;
        const updHosts = d?.updates?.hosts_with_updates ?? 0;
        const updPkgs = d?.updates?.total ?? 0;
        const failed24h = d?.jobs?.failed_runs_last_24h ?? 0;
        const freshest = d?.updates?.freshest_checked_at;

        if (onlineEl) onlineEl.textContent = `${hostsOnline} / ${hostsTotal}`;
        if (onlineDetailsEl) onlineDetailsEl.textContent = `${hostsOffline} offline (grace ${d?.hosts?.online_grace_seconds ?? 0}s)`;

        if (secEl) secEl.textContent = `${secHosts} hosts`;
        if (secDetailsEl) secDetailsEl.textContent = `${secPkgs} packages`;

        if (updEl) updEl.textContent = `${updHosts} hosts`;
        if (updDetailsEl) updDetailsEl.textContent = `${updPkgs} packages`;

        if (failEl) failEl.textContent = `${failed24h}`;

        if (freshEl) {
          freshEl.textContent = freshest ? new Date(freshest).toLocaleString() : '–';
        }

        if (attentionEl) {
          attentionEl.innerHTML = '<div class="loading">Loading attention list…</div>';
          try {
            const r2 = await fetch(`/dashboard/attention?limit=200&include_live=true&force_live=${forceLive ? 'true' : 'false'}`, { credentials: 'include' });
            if (!r2.ok) throw new Error(`attention failed (${r2.status})`);
            const a = await r2.json();
            const rows = a?.items || [];
            if (!rows.length) {
              attentionEl.innerHTML = '<div style="color:#86efac;">All clear. No high-priority issues detected.</div>';
            } else {
              const html = [];
              html.push('<div style="overflow:auto;">');
              html.push('<table class="process-table" style="min-width:800px;">');
              html.push('<thead><tr><th>Host</th><th>Issues</th><th>Last seen</th></tr></thead>');
              html.push('<tbody>');
              for (const it of rows) {
                const agentId = String(it.agent_id || '');
                const hostName = String(it.hostname || it.agent_id || '');
                const host = escapeHtml(hostName);
                const last = it.last_seen ? escapeHtml(formatShortTime(it.last_seen)) : '–';

                const issuesHtml = (it.issues || []).map(x => {
                  const kind = String(x.kind || '');
                  const msg = String(x.message || '');
                  return `<a href="#" class="attention-issue" data-agent-id="${escapeHtml(agentId)}" data-hostname="${escapeHtml(hostName)}" data-kind="${escapeHtml(kind)}" style="text-decoration:underline;">${escapeHtml(msg)}</a>`;
                }).join(', ');

                html.push(`<tr>
                  <td style="font-family:monospace;">${host}</td>
                  <td>${issuesHtml || ''}</td>
                  <td style="color:#94a3b8;">${last}</td>
                </tr>`);
              }
              html.push('</tbody></table></div>');
              attentionEl.innerHTML = html.join('');

              // Click handlers: take you to the exact drilldown for the issue.
              attentionEl.querySelectorAll('a.attention-issue').forEach(a => {
                a.addEventListener('click', (e) => {
                  e.preventDefault();
                  const aid = a.getAttribute('data-agent-id') || '';
                  const hostname = a.getAttribute('data-hostname') || aid;
                  const kind = a.getAttribute('data-kind') || '';
                  if (!aid) return;

                  // Select host in UI so context changes.
                  selectHost(aid, hostname);

                  if (kind === 'disk') {
                    openDiskModal(aid);
                    return;
                  }

                  if (kind === 'cpu') {
                    showServerInfo();
                    // Scroll to top processes table
                    document.getElementById('top-processes-body')?.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    return;
                  }

                  if (kind === 'security_updates' || kind === 'updates') {
                    showPackages();
                    // Prefer updates-only view if available
                    const updatesOnlyEl = document.getElementById('packages-updates-only');
                    if (updatesOnlyEl) {
                      updatesOnlyEl.checked = true;
                      packagesUpdatesOnly = true;
                      loadPackages(aid);
                    }
                    return;
                  }

                  if (kind === 'reboot_required') {
                    showToast('Host reports reboot required', 'info');
                    showServerInfo();
                    return;
                  }

                  if (kind === 'offline') {
                    showToast('Host appears offline', 'error');
                    return;
                  }

                  // fallback
                  showServerInfo();
                });
              });
            }
          } catch (e2) {
            attentionEl.innerHTML = `<div class="error">Attention list error: ${escapeHtml(e2.message || String(e2))}</div>`;
          }
        }
      } catch (e) {
        if (attentionEl) attentionEl.textContent = `Overview error: ${e.message}`;
      }

      // Best-effort: keep the report warm
      loadPendingUpdatesReport();
    }

    async function loadFailedRuns(hours = 24, showToastOnManual = false) {
      const tbody = document.getElementById('overview-failed-runs');
      if (!tbody) return;
      try {
        setTableState(tbody, 5, 'loading', 'Loading…');
        const r = await fetch(`/dashboard/failed-runs?hours=${encodeURIComponent(hours)}&limit=200`, { credentials: 'include' });
        if (!r.ok) throw new Error(`failed-runs fetch failed (${r.status})`);
        const d = await r.json();
        const items = d?.items || [];
        if (!items.length) {
          setTableState(tbody, 5, 'empty', 'No failed runs 🎯');
          return;
        }
        tbody.innerHTML = '';
        for (const it of items) {
          const when = formatShortTime(it.finished_at);
          const host = it.agent_id || '–';
          const job = `${it.job_type || 'job'}${it.job_key ? ' • ' + it.job_key : ''}`.trim();
          const exit = (it.exit_code === null || it.exit_code === undefined) ? '–' : String(it.exit_code);
          const err = (it.error || (it.stderr || '').split('\n').slice(-1)[0] || '').trim();

          const tr = document.createElement('tr');
          tr.style.cursor = 'pointer';
          tr.innerHTML = `
            <td style="color:#94a3b8;">${escapeHtml(when)}</td>
            <td><b>${escapeHtml(host)}</b></td>
            <td>${escapeHtml(job)}</td>
            <td style="text-align:right;">${escapeHtml(exit)}</td>
            <td style="color:#fca5a5;">${escapeHtml(err || 'failed')}</td>
          `;

          tr.addEventListener('click', () => {
            const detail = [
              `Host: ${host}`,
              `Job: ${job}`,
              it.finished_at ? `When: ${new Date(it.finished_at).toLocaleString()}` : '',
              (it.exit_code === null || it.exit_code === undefined) ? '' : `Exit: ${it.exit_code}`,
              '',
              '--- error ---',
              (it.error || ''),
              '',
              '--- stderr ---',
              (it.stderr || ''),
              '',
              '--- stdout ---',
              (it.stdout || ''),
            ].filter(Boolean).join('\n');
            alert(detail);
          });

          tbody.appendChild(tr);
        }
        if (showToastOnManual) showToast('Failed runs refreshed', 'success');
      } catch (e) {
        setTableState(tbody, 5, 'error', e.message || String(e));
        if (showToastOnManual) showToast(e.message, 'error');
      }
    }

    function formatShortTime(iso) {
      if (!iso) return '–';
      try {
        return new Date(iso).toLocaleString();
      } catch {
        return String(iso);
      }
    }

    async function loadHostsTable() {
      const tbody = document.getElementById('hosts-table-body');
      if (!tbody) return;

      const sortSel = document.getElementById('hosts-sort');
      const orderSel = document.getElementById('hosts-order');
      const sort = sortSel?.value || 'hostname';
      const order = orderSel?.value || 'asc';

      try {
        setTableState(tbody, 9, 'loading', 'Loading…');
        const url = `/reports/hosts-updates?only_pending=false&online_only=false&sort=${encodeURIComponent(sort)}&order=${encodeURIComponent(order)}&limit=500`;
        const r = await fetch(url, { credentials: 'include' });
        if (!r.ok) throw new Error(`hosts report failed (${r.status})`);
        const d = await r.json();
        const items = d?.items || [];

        if (!items.length) {
          setTableState(tbody, 9, 'empty', 'No hosts');
          return;
        }

        tbody.innerHTML = '';
        for (const it of items) {
          const hostName = it.hostname || it.agent_id;
          const os = `${it.os_id || ''} ${it.os_version || ''}`.trim() || '–';
          const kernel = it.kernel || '–';
          const sec = Number(it.security_updates || 0);
          const all = Number(it.updates || 0);
          const online = it.is_online ? '<span style="color:#86efac;">online</span>' : '<span style="color:#fca5a5;">offline</span>';
          const reboot = it.reboot_required ? '<span style="color:#fbbf24;">required</span>' : '<span style="color:#94a3b8;">no</span>';
          const lastSeen = formatShortTime(it.last_seen);

          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td><input type="checkbox" class="hosts-row-select" data-agent-id="${escapeHtml(it.agent_id || '')}" /></td>
            <td><b>${escapeHtml(hostName)}</b><div style="color:#94a3b8;font-size:0.85rem;">${escapeHtml(it.agent_id || '')} ${it.ip_address ? '• ' + escapeHtml(it.ip_address) : ''}</div></td>
            <td>${escapeHtml(os)}</td>
            <td><code>${escapeHtml(kernel)}</code></td>
            <td style="text-align:right;"><b>${sec}</b></td>
            <td style="text-align:right;"><b>${all}</b></td>
            <td>${reboot}</td>
            <td>${online}</td>
            <td style="color:#94a3b8;">${escapeHtml(lastSeen)}</td>
          `;
          tbody.appendChild(tr);
        }
      } catch (e) {
        setTableState(tbody, 9, 'error', `Hosts table error: ${e.message || String(e)}`);
      }
    }

    function getSelectedHostAgentIds() {
      const ids = [];
      document.querySelectorAll('.hosts-row-select:checked').forEach(cb => {
        const aid = cb.getAttribute('data-agent-id') || '';
        if (aid) ids.push(aid);
      });
      return ids;
    }

    function initHostsTableControls() {
      document.getElementById('hosts-reload')?.addEventListener('click', (e) => {
        e.preventDefault();
        loadHostsTable();
      });
      document.getElementById('hosts-sort')?.addEventListener('change', loadHostsTable);
      document.getElementById('hosts-order')?.addEventListener('change', loadHostsTable);

      document.getElementById('hosts-select-all')?.addEventListener('change', (e) => {
        const checked = !!e.target.checked;
        document.querySelectorAll('.hosts-row-select').forEach(cb => { cb.checked = checked; });
      });

      async function bulkPost(url, payload, okMsg) {
        const statusEl = document.getElementById('hosts-bulk-status');
        if (statusEl) statusEl.textContent = 'Working…';
        try {
          const r = await fetch(url, {
            method: 'POST',
            credentials: 'include',
            headers: { 'content-type': 'application/json' },
            body: JSON.stringify(payload),
          });
          if (!r.ok) throw new Error(`${url} failed (${r.status})`);
          const d = await r.json();
          showToast(okMsg, 'success');
          if (statusEl) statusEl.textContent = '';
          return d;
        } catch (e) {
          showToast(e.message, 'error');
          if (statusEl) statusEl.textContent = '';
        }
      }

      document.getElementById('hosts-bulk-inventory')?.addEventListener('click', async (e) => {
        e.preventDefault();
        const ids = getSelectedHostAgentIds();
        if (!ids.length) return showToast('Select hosts first', 'error');
        await bulkPost('/jobs/inventory-now', { agent_ids: ids }, `Triggered inventory for ${ids.length} hosts`);
      });

      document.getElementById('hosts-bulk-security')?.addEventListener('click', async (e) => {
        e.preventDefault();
        const ids = getSelectedHostAgentIds();
        if (!ids.length) return showToast('Select hosts first', 'error');
        const now = new Date();
        const end = new Date(now.getTime() + 60 * 60 * 1000);
        const payload = {
          agent_ids: ids,
          window_start: now.toISOString(),
          window_end: end.toISOString(),
          concurrency: 5,
          reboot_if_needed: true,
          include_kernel: false,
        };
        await bulkPost('/patching/campaigns/security-updates', payload, `Security campaign scheduled for ${ids.length} hosts`);
      });

      document.getElementById('hosts-bulk-dist')?.addEventListener('click', async (e) => {
        e.preventDefault();
        const ids = getSelectedHostAgentIds();
        if (!ids.length) return showToast('Select hosts first', 'error');
        await bulkPost('/jobs/dist-upgrade', { agent_ids: ids }, `dist-upgrade queued for ${ids.length} hosts`);
      });

      // Cleanup offline hosts
      document.getElementById('hosts-cleanup-offline')?.addEventListener('click', async (e) => {
        e.preventDefault();
        const minsStr = prompt('Delete hosts that have been offline for how many minutes?', '60');
        if (minsStr === null) return;
        const mins = parseInt((minsStr || '').trim(), 10);
        if (!Number.isFinite(mins) || mins < 1) {
          showToast('Enter a valid number of minutes (>= 1)', 'error');
          return;
        }

        // Dry run preview
        try {
          const previewResp = await fetch(`/hosts/cleanup-offline?older_than_minutes=${encodeURIComponent(mins)}&dry_run=true`, {
            method: 'POST',
            credentials: 'include'
          });
          if (!previewResp.ok) throw new Error(`preview failed (${previewResp.status})`);
          const preview = await previewResp.json();
          const n = preview?.count || 0;
          const agentIds = (preview?.agent_ids || []).slice(0, 12);
          const more = (preview?.agent_ids || []).length > 12 ? `\n… and ${(preview.agent_ids.length - 12)} more` : '';

          const msg = n
            ? `This will DELETE ${n} host(s) last seen before ${preview.cutoff}.\n\n${agentIds.join('\n')}${more}\n\nProceed?`
            : `No hosts are older than ${mins} minutes. (cutoff: ${preview.cutoff})`;

          if (!n) {
            showToast('No offline hosts to delete', 'success');
            return;
          }

          if (!confirm(msg)) return;

          const resp = await fetch(`/hosts/cleanup-offline?older_than_minutes=${encodeURIComponent(mins)}`, {
            method: 'POST',
            credentials: 'include'
          });
          if (!resp.ok) throw new Error(`cleanup failed (${resp.status})`);
          const out = await resp.json();
          showToast(`Deleted ${out?.deleted?.length || 0} host(s)`, 'success');

          // Reload lists
          await loadHosts();
          await loadHostsTable();
        } catch (err) {
          showToast(err.message || String(err), 'error');
        }
      });

      // Click-sort headers
      function setSort(key) {
        const sortSel = document.getElementById('hosts-sort');
        const orderSel = document.getElementById('hosts-order');
        if (!sortSel || !orderSel) return;
        const cur = sortSel.value;
        const curOrd = orderSel.value;
        if (cur === key) orderSel.value = (curOrd === 'asc') ? 'desc' : 'asc';
        else { sortSel.value = key; orderSel.value = 'asc'; }
        updateHostsSortIndicators(sortSel.value, orderSel.value);
        loadHostsTable();
      }
      updateHostsSortIndicators(sort, order);
      bindSortableHeader('hosts-th-host', () => setSort('hostname'));
      bindSortableHeader('hosts-th-os', () => setSort('os_version'));
      bindSortableHeader('hosts-th-upd', () => setSort('updates'));
      bindSortableHeader('hosts-th-sec', () => setSort('security_updates'));
      bindSortableHeader('hosts-th-last', () => setSort('last_seen'));
    }

    async function loadPendingUpdatesReport(showToastOnManual = false) {
      const tbody = document.getElementById('overview-updates-report');
      if (!tbody) return;

      const sortSel = document.getElementById('report-sort');
      const orderSel = document.getElementById('report-order');
      const sort = sortSel?.value || 'security_updates';
      const order = orderSel?.value || 'desc';
      updateReportSortIndicators(sort, order);
      setTableState(tbody, 7, 'loading', 'Loading…');

      try {
        const url = `/reports/hosts-updates?only_pending=true&online_only=false&sort=${encodeURIComponent(sort)}&order=${encodeURIComponent(order)}&limit=100`;
        const r = await fetch(url, { credentials: 'include' });
        if (!r.ok) throw new Error(`report failed (${r.status})`);
        const d = await r.json();
        const items = d?.items || [];
        if (showToastOnManual) showToast('Report refreshed', 'success');

        if (!items.length) {
          setTableState(tbody, 7, 'empty', 'No pending updates 🎯');
          return;
        }

        tbody.innerHTML = '';
        for (const it of items) {
          const hostName = it.hostname || it.agent_id;
          const os = `${it.os_id || ''} ${it.os_version || ''}`.trim() || '–';
          const kernel = it.kernel || '–';
          const sec = Number(it.security_updates || 0);
          const all = Number(it.updates || 0);
          const online = it.is_online ? '<span style="color:#86efac;">online</span>' : '<span style="color:#fca5a5;">offline</span>';
          const lastSeen = formatShortTime(it.last_seen);

          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td><b>${escapeHtml(hostName)}</b><div style="color:#94a3b8;font-size:0.85rem;">${escapeHtml(it.agent_id || '')} ${it.ip_address ? '• ' + escapeHtml(it.ip_address) : ''}</div></td>
            <td>${escapeHtml(os)}</td>
            <td><code>${escapeHtml(kernel)}</code></td>
            <td><b>${sec}</b></td>
            <td><b>${all}</b></td>
            <td>${online}</td>
            <td style="color:#94a3b8;">${escapeHtml(lastSeen)}</td>
          `;
          tbody.appendChild(tr);
        }
      } catch (e) {
        if (showToastOnManual) showToast(`Report refresh failed: ${e.message}`, 'error');
        setTableState(tbody, 7, 'error', `Report error: ${e.message}`);
      }
    }

    function initFleetOverviewControls() {
      const navOverview = document.getElementById('nav-overview');
      const navHosts = document.getElementById('nav-hosts');
      const navCronjobs = document.getElementById('nav-cronjobs');
      const navSshKeys = document.getElementById('nav-sshkeys');
      const containerEl = document.querySelector('.container');

      function showOverviewTab() {
        // Clicking Fleet "Overview" should not keep a per-host selection active
        // in the Hosts management pane.
        clearCurrentHostSelection();

        document.querySelectorAll('.tab-content-custom, .tab-content').forEach(c => c.classList.remove('active'));
        document.getElementById('server-info-tab')?.classList.add('active');
        if (containerEl) containerEl.classList.add('sidebar-collapsed');
        loadFleetOverview();
      }

      function showHostsTab() {
        // Stop metrics updates when leaving server info view
        stopMetricsPolling(metricsLifecycleState);
        

        // Clicking Fleet "Hosts" should not keep a per-host selection active
        // in the Hosts management pane.
        clearCurrentHostSelection();

        document.querySelectorAll('.tab-content-custom, .tab-content').forEach(c => c.classList.remove('active'));
        document.getElementById('hosts-table-tab')?.classList.add('active');
        if (containerEl) containerEl.classList.remove('sidebar-collapsed');
        loadHostsTable();
      }

      function showCronjobsTab() {
        // Cronjobs is fleet-level; clear any per-host selection
        clearCurrentHostSelection();
        document.querySelectorAll('.tab-content-custom, .tab-content').forEach(c => c.classList.remove('active'));
        document.getElementById('cronjobs-tab')?.classList.add('active');
        if (containerEl) containerEl.classList.add('sidebar-collapsed');
        loadCronjobs();
      }

      function showSshKeysTab() {
        clearCurrentHostSelection();
        document.querySelectorAll('.tab-content-custom, .tab-content').forEach(c => c.classList.remove('active'));
        document.getElementById('sshkeys-tab')?.classList.add('active');
        if (containerEl) containerEl.classList.add('sidebar-collapsed');
        loadSshKeys();
        loadSshKeyRequests();
        maybeLoadSshKeyAdminQueue();
        loadAdminSshKeys();
      }

      navOverview?.addEventListener('click', (e) => { e.preventDefault(); showOverviewTab(); });
      navHosts?.addEventListener('click', (e) => { e.preventDefault(); showHostsTab(); });
      navCronjobs?.addEventListener('click', (e) => { e.preventDefault(); showCronjobsTab(); });
      navSshKeys?.addEventListener('click', (e) => { e.preventDefault(); showSshKeysTab(); });

      // Ensure initial state is consistent with the default active tab
      showOverviewTab();

      const refreshBtn = document.getElementById('overview-refresh');
      const invBtn = document.getElementById('overview-inventory-now');
      const secBtn = document.getElementById('overview-security-campaign');
      const distBtn = document.getElementById('overview-dist-upgrade');

      const failedRunsRefreshBtn = document.getElementById('failed-runs-refresh');
      wireBusyClick(failedRunsRefreshBtn, 'Refreshing…', async () => {
        await loadFailedRuns(24, true);
      });

      wireBusyClick(refreshBtn, 'Refreshing…', async () => {
        // Force live refresh so disk/CPU alerts clear quickly after you fix them.
        await Promise.allSettled([loadFleetOverview(true), loadPendingUpdatesReport(), loadHosts()]);
      });

      wireBusyClick(invBtn, 'Queueing…', async () => {
        const agentIds = (lastRenderedAgentIds || []).slice();
        if (!agentIds.length) return showToast('No visible hosts to inventory', 'error');
        const r = await fetch('/jobs/inventory-now', {
          method: 'POST',
          credentials: 'include',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ agent_ids: agentIds }),
        });
        if (!r.ok) return showToast('Inventory-now failed', 'error');
        showToast(`Triggered inventory for ${agentIds.length} hosts`, 'success');
        setTimeout(loadPendingUpdatesReport, 1500);
      });

      wireBusyClick(secBtn, 'Scheduling…', async () => {
        const agentIds = (lastRenderedAgentIds || []).slice();
        if (!agentIds.length) return showToast('No visible hosts selected', 'error');
        const now = new Date();
        const end = new Date(now.getTime() + 60 * 60 * 1000);
        const payload = {
          agent_ids: agentIds,
          window_start: now.toISOString(),
          window_end: end.toISOString(),
          concurrency: 5,
          reboot_if_needed: true,
          include_kernel: false,
        };
        const r = await fetch('/patching/campaigns/security-updates', {
          method: 'POST',
          credentials: 'include',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify(payload),
        });
        if (!r.ok) return showToast('Campaign creation failed', 'error');
        const d = await r.json();
        showToast(`Security campaign scheduled: ${d.campaign_id}`, 'success');
      });

      wireBusyClick(distBtn, 'Queueing…', async () => {
        const agentIds = (lastRenderedAgentIds || []).slice();
        if (!agentIds.length) return showToast('No visible hosts selected', 'error');
        const r = await fetch('/jobs/dist-upgrade', {
          method: 'POST',
          credentials: 'include',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ agent_ids: agentIds }),
        });
        if (!r.ok) return showToast('dist-upgrade job creation failed', 'error');
        const d = await r.json();
        showToast(`dist-upgrade queued: ${d.job_id}`, 'success');
      });

      const reportRefresh = document.getElementById('report-refresh');
      wireBusyClick(reportRefresh, 'Refreshing…', async () => {
        await loadPendingUpdatesReport(true);
      });
      document.getElementById('report-sort')?.addEventListener('change', loadPendingUpdatesReport);
      document.getElementById('report-order')?.addEventListener('change', loadPendingUpdatesReport);

      setupReportSortHandlers(loadPendingUpdatesReport);
      setupKpiHandlers(showHostsTab, showOverviewTab, loadFailedRuns);
    }

    

    async function loadCronjobs(showToastOnManual = false) {
      const tbody = document.getElementById('cronjobs-table');
      if (!tbody) return;
      try {
        setTableState(tbody, 6, 'loading', 'Loading…');
        const r = await fetch('/cronjobs', { credentials: 'include' });
        if (!r.ok) throw new Error(`cronjobs failed (${r.status})`);
        const d = await r.json();
        const items = d?.items || [];
        if (!items.length) {
          setTableState(tbody, 6, 'empty', 'No cronjobs yet');
          return;
        }
        tbody.innerHTML = '';
        for (const it of items) {
          const tr = document.createElement('tr');
          const when = formatShortTime(it.run_at);
          const targets = Array.isArray(it.selector?.agent_ids) ? it.selector.agent_ids.length : '–';
          const status = it.status || '–';
          tr.innerHTML = `
            <td style="color:#94a3b8;">${escapeHtml(when)}</td>
            <td>${escapeHtml(it.name || '')}</td>
            <td><code>${escapeHtml(it.action || '')}</code></td>
            <td>${escapeHtml(String(targets))}</td>
            <td>${escapeHtml(status)}</td>
            <td style="text-align:right;">
              ${(() => {
                const jk = it.latest_run?.job_key || '';
                if (jk && !jk.startsWith('patch-campaign:')) {
                  return `<a class="btn" href="/jobs/${encodeURIComponent(jk)}/logs.zip" target="_blank" rel="noopener">Download logs</a>`;
                }
                return '';
              })()}
              ${status === 'scheduled' ? ` <button class="btn" data-cancel-id="${escapeHtml(it.id)}">Cancel</button>` : ''}
            </td>
          `;
          tbody.appendChild(tr);
        }
        // wire cancel buttons
        tbody.querySelectorAll('button[data-cancel-id]').forEach(btn => {
          btn.addEventListener('click', async (e) => {
            e.preventDefault();
            const id = btn.getAttribute('data-cancel-id');
            if (!id) return;
            const r2 = await fetch(`/cronjobs/${encodeURIComponent(id)}/cancel`, { method: 'POST', credentials: 'include' });
            if (!r2.ok) return showToast('Cancel failed', 'error');
            showToast('Cronjob canceled', 'success');
            loadCronjobs();
          });
        });
        if (showToastOnManual) showToast('Cronjobs refreshed', 'success');
      } catch (e) {
        setTableState(tbody, 6, 'error', e.message || String(e));
        if (showToastOnManual) showToast(e.message, 'error');
      }
    }


    // Cronjobs host picker (separate from Hosts tab selection)
    const cronUiState = createUiStateAccess('cronHostPicker', { selectedAgentIds: new Set() });
    const cronUiDefaults = (typeof window.initCronHostPickerState === 'function')
      ? window.initCronHostPickerState(cronUiState)
      : { selectedAgentIds: (cronUiState.get('selectedAgentIds') instanceof Set) ? cronUiState.get('selectedAgentIds') : new Set() };

    function getCronSelectedAgentIds() {
      return cronUiState.get('selectedAgentIds', cronUiDefaults.selectedAgentIds);
    }

    function setCronSelectedAgentIds(next) {
      return cronUiState.set('selectedAgentIds', (next instanceof Set) ? next : new Set());
    }

    function setCronHostsPanelVisible(visible) {
      const panel = document.getElementById('cron-hosts-panel');
      if (!panel) return;
      panel.style.display = visible ? 'block' : 'none';
    }

    function renderCronHostsList() {
      const listEl = document.getElementById('cron-hosts-list');
      const countEl = document.getElementById('cron-hosts-count');
      if (!listEl) return;

      const selectedAgentIds = getCronSelectedAgentIds();
      const q = (document.getElementById('cron-hosts-search')?.value || '').trim().toLowerCase();
      const hosts = (allHosts || []).slice();

      listEl.innerHTML = '';
      if (!hosts.length) {
        listEl.innerHTML = '<div class="empty-state" style="padding:0.75rem;">No hosts loaded yet.</div>';
        if (countEl) countEl.textContent = String(selectedAgentIds.size);
        return;
      }

      for (const h of hosts) {
        const aid = h.agent_id || '';
        const name = h.hostname || aid;
        const ip = h.ip_address || '';
        const os = `${h.os_id || ''} ${h.os_version || ''}`.trim();
        const hay = `${name} ${aid} ${ip} ${os}`.toLowerCase();
        if (q && !hay.includes(q)) continue;

        const row = document.createElement('label');
        row.style.display = 'flex';
        row.style.alignItems = 'center';
        row.style.justifyContent = 'space-between';
        row.style.gap = '0.75rem';
        row.style.padding = '0.5rem 0.6rem';
        row.style.borderRadius = '8px';
        row.style.cursor = 'pointer';
        row.style.background = 'transparent';

        const left = document.createElement('div');
        left.style.display = 'flex';
        left.style.flexDirection = 'column';
        left.style.gap = '0.1rem';

        const title = document.createElement('div');
        title.innerHTML = `<b>${escapeHtml(name)}</b> <span style="color:#94a3b8;font-size:0.85rem;">${escapeHtml(aid)}</span>`;
        const sub = document.createElement('div');
        sub.style.color = '#94a3b8';
        sub.style.fontSize = '0.85rem';
        sub.textContent = ip ? ip : '';

        left.appendChild(title);
        if (ip) left.appendChild(sub);

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = selectedAgentIds.has(aid);
        cb.addEventListener('change', () => {
          if (cb.checked) selectedAgentIds.add(aid);
          else selectedAgentIds.delete(aid);
          if (countEl) countEl.textContent = String(selectedAgentIds.size);
        });

        row.appendChild(left);
        row.appendChild(cb);
        row.addEventListener('mouseenter', () => { row.style.background = 'color-mix(in srgb, var(--panel) 55%, transparent)'; });
        row.addEventListener('mouseleave', () => { row.style.background = 'transparent'; });

        listEl.appendChild(row);
      }

      if (countEl) countEl.textContent = String(selectedAgentIds.size);
    }
    function initCronjobsControls() {

      setupCronScheduleUi();

      setupCronHostPickerControls({
        setPanelVisible: setCronHostsPanelVisible,
        renderList: renderCronHostsList,
        selectAll: () => {
          const selectedAgentIds = getCronSelectedAgentIds();
          (allHosts || []).forEach(h => { if (h.agent_id) selectedAgentIds.add(h.agent_id); });
        },
        clearSelection: () => {
          setCronSelectedAgentIds(new Set());
        },
      });

      const cronRefreshBtn = document.getElementById('cron-refresh');
      wireBusyClick(cronRefreshBtn, 'Refreshing…', async () => {
        await loadCronjobs(true);
      });

      const cronCreateBtn = document.getElementById('cron-create');
      cronCreateBtn?.addEventListener('click', async (e) => {
        e.preventDefault();
        await handleCronCreate({
          createBtn: cronCreateBtn,
          statusEl: document.getElementById('cron-create-status'),
          getSelectedAgentIds: () => Array.from(getCronSelectedAgentIds() || []),
          setPanelVisible: setCronHostsPanelVisible,
          renderList: renderCronHostsList,
          loadCronjobs: loadCronjobs,
          withBusyButton: withBusyButton,
        });
      });
    }

    // SSH Keys UI
    const sshUiState = createUiStateAccess('sshKeys', {
      keysCache: [],
      selectedKeyId: null,
      selectedAgentIds: new Set(),
    });
    const sshUiDefaults = (typeof window.initSshKeysUiState === 'function')
      ? window.initSshKeysUiState(sshUiState)
      : {
        keysCache: Array.isArray(sshUiState.get('keysCache')) ? sshUiState.get('keysCache') : [],
        selectedKeyId: sshUiState.get('selectedKeyId', null) || null,
        selectedAgentIds: (sshUiState.get('selectedAgentIds') instanceof Set) ? sshUiState.get('selectedAgentIds') : new Set(),
      };

    function getSshSelectedAgentIds() {
      return sshUiState.get('selectedAgentIds', sshUiDefaults.selectedAgentIds);
    }

    function setSshSelectedAgentIds(next) {
      return sshUiState.set('selectedAgentIds', (next instanceof Set) ? next : new Set());
    }

    function getSshSelectedKeyId() {
      return sshUiState.get('selectedKeyId', sshUiDefaults.selectedKeyId);
    }

    function setSshSelectedKeyId(next) {
      return sshUiState.set('selectedKeyId', next || null);
    }

    function getSshKeysCache() {
      return sshUiState.get('keysCache', sshUiDefaults.keysCache);
    }

    function setSshKeysCache(next) {
      return sshUiState.set('keysCache', Array.isArray(next) ? next : []);
    }

    function setSshHostsPanelVisible(v) {
      setPanelVisibleById('sshkey-hosts-panel', v);
    }

    function renderSshHostsList() {
      const selectedAgentIds = getSshSelectedAgentIds();
      const nextSelected = renderSshHostsListView({
        hosts: (allHosts || []),
        selectedAgentIds: selectedAgentIds,
        listId: 'sshkey-hosts-list',
        countId: 'sshkey-hosts-count',
        searchId: 'sshkey-hosts-search',
      }) || selectedAgentIds;
      setSshSelectedAgentIds(nextSelected);
    }

    async function loadSshKeys(showToastOnManual = false) {
      const tbody = document.getElementById('sshkeys-table');
      if (!tbody) return;
      try {
        setTableState(tbody, 4, 'loading', 'Loading…');
        const r = await fetch('/sshkeys', { credentials: 'include' });
        if (!r.ok) throw new Error(`sshkeys failed (${r.status})`);
        const d = await r.json();
        setSshKeysCache(d?.items || []);
        if (!getSshKeysCache().length) {
          setTableState(tbody, 4, 'empty', 'No keys yet');
          return;
        }
        tbody.innerHTML = '';
        for (const k of getSshKeysCache()) {
          const tr = document.createElement('tr');
          tr.style.cursor = 'pointer';
          const selectedKeyId = getSshSelectedKeyId();
          const isSel = (selectedKeyId && selectedKeyId === k.id);
          tr.innerHTML = `
            <td>${escapeHtml(k.name || '')}</td>
            <td><code>${escapeHtml(k.fingerprint || '')}</code></td>
            <td style="max-width:520px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;"><code>${escapeHtml(k.public_key || '')}</code></td>
            <td style="text-align:right;"><button class="btn" data-revoke-id="${escapeHtml(k.id)}">Delete</button></td>
          `;
          if (isSel) tr.style.background = 'color-mix(in srgb, var(--primary) 12%, var(--panel))';
          tr.setAttribute('data-key-id', k.id);
          tr.addEventListener('click', (e) => {
            if ((e.target && e.target.tagName || '').toLowerCase() === 'button') return;
            setSshSelectedKeyId(k.id);
            // Highlight immediately.
            Array.from(tbody.querySelectorAll('tr[data-key-id]')).forEach(row => {
              const rowId = row.getAttribute('data-key-id');
              if (rowId && rowId === getSshSelectedKeyId()) {
                row.style.background = 'color-mix(in srgb, var(--primary) 12%, var(--panel))';
              } else {
                row.style.background = '';
              }
            });
          });
          tbody.appendChild(tr);
        }
        tbody.querySelectorAll('button[data-revoke-id]').forEach(btn => {
          btn.addEventListener('click', async (e) => {
            e.preventDefault();
            const id = btn.getAttribute('data-revoke-id');
            if (!id) return;
            const r2 = await fetch(`/sshkeys/${encodeURIComponent(id)}`, { method: 'DELETE', credentials: 'include' });
            if (!r2.ok) return showToast('Delete failed', 'error');
            if (getSshSelectedKeyId() === id) setSshSelectedKeyId(null);
            showToast('Key deleted', 'success');
            loadSshKeys();
          });
        });
        if (showToastOnManual) showToast('SSH keys refreshed', 'success');
      } catch (e) {
        setTableState(tbody, 4, 'error', e.message || String(e));
        if (showToastOnManual) showToast(e.message, 'error');
      }
    }

    async function loadSshKeyRequests() {
      const tbody = document.getElementById('sshkey-requests-table');
      if (!tbody) return;
      try {
        setTableState(tbody, 6, 'loading', 'Loading…');
        const r = await fetch('/sshkeys/deploy-requests', { credentials: 'include' });
        if (!r.ok) throw new Error(`requests failed (${r.status})`);
        const d = await r.json();
        const items = d?.items || [];
        if (!items.length) {
          setTableState(tbody, 6, 'empty', 'No requests');
          return;
        }
        tbody.innerHTML = '';
        for (const it of items) {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td style="color:#94a3b8;">${escapeHtml(formatShortTime(it.created_at))}</td>
            <td><code>${escapeHtml(String(it.key_id || '')).slice(0,8)}</code></td>
            <td>${escapeHtml(String((it.agent_ids||[]).length))}</td>
            <td>${escapeHtml(it.status || '')}</td>
            <td>${escapeHtml(it.approved_by || '')}</td>
            <td style="color:#fca5a5;">${escapeHtml(it.error || '')}</td>
          `;
          tbody.appendChild(tr);
        }
      } catch (e) {
        setTableState(tbody, 6, 'error', e.message || String(e));
      }
    }

    async function loadAdminSshKeys() {
      const panel = document.getElementById('sshkey-admin-keys');
      const tbody = document.getElementById('sshkey-admin-keys-table');
      if (!panel || !tbody) return;

      const isAdmin = (currentPermissions && String(currentPermissions.role||'').toLowerCase() === 'admin') || !!currentPermissions.can_manage_users;
      if (!isAdmin) {
        panel.style.display = 'none';
        return;
      }
      panel.style.display = 'block';

      try {
        setTableState(tbody, 5, 'loading', 'Loading…');
        const r = await fetch('/sshkeys/admin/keys', { credentials: 'include' });
        if (!r.ok) throw new Error(`admin keys failed (${r.status})`);
        const d = await r.json();
        const items = d?.items || [];
        if (!items.length) {
          setTableState(tbody, 5, 'empty', 'No keys');
          return;
        }
        tbody.innerHTML = '';
        for (const k of items) {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td style="color:#94a3b8;">${escapeHtml(formatShortTime(k.created_at))}</td>
            <td>${escapeHtml(k.user_name || String(k.user_id||'').slice(0,8))}</td>
            <td>${escapeHtml(k.name || '')}</td>
            <td><code>${escapeHtml(k.fingerprint || '')}</code></td>
            <td style="max-width:520px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;"><code>${escapeHtml(k.public_key || '')}</code></td>
          `;
          tbody.appendChild(tr);
        }
      } catch (e) {
        setTableState(tbody, 5, 'error', e.message || String(e));
      }
    }

    async function maybeLoadSshKeyAdminQueue() {
      const panel = document.getElementById('sshkey-admin-approvals');
      const tbody = document.getElementById('sshkey-admin-table');
      if (!panel || !tbody) return;
      // Only show for admin users
      const isAdmin = (currentPermissions && String(currentPermissions.role||'').toLowerCase() === 'admin') || !!currentPermissions.can_manage_users;
      if (!isAdmin) {
        panel.style.display = 'none';
        const indicator = document.getElementById('sshkeys-approval-indicator');
        if (indicator) indicator.style.display = 'none';
        return;
      }
      panel.style.display = 'block';
      try {
        const r = await fetch('/sshkeys/admin/deploy-requests', { credentials: 'include' });
        if (!r.ok) throw new Error(`admin queue failed (${r.status})`);
        const d = await r.json();
        const items = d?.items || [];

        const indicator = document.getElementById('sshkeys-approval-indicator');
        if (indicator) indicator.style.display = items.length ? 'inline' : 'none';

        if (!items.length) {
          tbody.innerHTML = '<tr><td colspan="5" style="text-align:center;color:#a0aec0;">No pending approvals</td></tr>';
          return;
        }
        tbody.innerHTML = '';

        const itemsById = new Map();
        for (const it of items) itemsById.set(String(it.id), it);

        const targetsLabel = (it) => {
          const targets = it.targets || (it.agent_ids || []).map(aid => ({ agent_id: String(aid), hostname: String(aid) }));
          const names = targets.map(t => t.hostname || t.agent_id).filter(Boolean);
          const preview = names.slice(0, 3).join(', ');
          const more = names.length > 3 ? ` (+${names.length - 3} more)` : '';
          return { text: preview + more, title: names.join('\n') };
        };

        for (const it of items) {
          const tr = document.createElement('tr');
          const t = targetsLabel(it);
          tr.innerHTML = `
            <td style="color:#94a3b8;">${escapeHtml(formatShortTime(it.created_at))}</td>
            <td>${escapeHtml(it.user_name || String(it.user_id||'').slice(0,8))}</td>
            <td><code>${escapeHtml(String(it.key_name||'') || String(it.key_id||'').slice(0,8))}</code></td>
            <td title="${escapeHtml(t.title)}">${escapeHtml(t.text || String((it.agent_ids||[]).length))}</td>
            <td style="text-align:right;white-space:nowrap;">
              <button class="btn" data-view-id="${escapeHtml(it.id)}">Details</button>
              <button class="btn btn-primary" data-approve-id="${escapeHtml(it.id)}">Approve</button>
              <button class="btn" data-reject-id="${escapeHtml(it.id)}">Reject</button>
            </td>
          `;
          tbody.appendChild(tr);
        }

        tbody.querySelectorAll('button[data-view-id]').forEach(btn => {
          btn.addEventListener('click', (e) => {
            e.preventDefault();
            const id = btn.getAttribute('data-view-id');
            const it = itemsById.get(String(id));
            if (!it) return;
            openSshKeyDeployApprovalModal(it);
          });
        });

        tbody.querySelectorAll('button[data-approve-id]').forEach(btn => {
          btn.addEventListener('click', async (e) => {
            e.preventDefault();
            const id = btn.getAttribute('data-approve-id');
            if (!id) return;

            const it = itemsById.get(String(id));
            if (it) {
              const t = targetsLabel(it);
              const keyShort = (String(it.key_id||'')).slice(0,8);
              const keyLabel = (String(it.key_name||'').trim()) ? `${it.key_name} (${keyShort})` : keyShort;
              const ok = confirm(`Approve deployment request?\n\nRequested by: ${it.user_name || it.user_id}\nKey: ${keyLabel}\nTargets:\n${t.title}`);
              if (!ok) return;
            }

            const r2 = await fetch(`/sshkeys/admin/deploy-requests/${encodeURIComponent(id)}/approve`, { method: 'POST', credentials: 'include' });
            const raw = await r2.text();
            let data = null;
            try { data = raw ? JSON.parse(raw) : null; } catch { }
            if (!r2.ok) {
              const msg = (data && (data.detail || data.error)) ? (data.detail || data.error) : (raw || 'Approve failed');
              return showToast(msg, 'error');
            }
            if (data && String(data.status||'') === 'failed') {
              showToast(data.error || 'Request marked failed', 'error');
              maybeLoadSshKeyAdminQueue();
              return;
            }

            // If backend returned a job_id, poll and show outcome so admins get immediate feedback.
            const jobId = data && (data.job_id || data.jobId);
            if (jobId) {
              showToast('Approved (waiting for agent result)…', 'info', 4500);
              try {
                const res = await waitForJobDone(String(jobId), 60000);
                const runSummary = (res.runs || []).map(r => `${r.agent_id}: ${r.status}${r.exit_code != null ? ` (exit ${r.exit_code})` : ''}${r.error ? ` — ${r.error}` : ''}`).join('\n');
                if (res.done && (res.runs || []).every(r => r.status === 'success')) {
                  showToast('Deployment completed successfully', 'success', 5000);
                } else if (res.done) {
                  showToast('Deployment finished with errors (open Details)', 'error', 6000);
                } else {
                  showToast('Deployment still running (check Jobs/logs)', 'info', 6000);
                }

                // Also open the details modal with targets + job outcome.
                const it2 = itemsById.get(String(id)) || it;
                if (it2) {
                  openSshKeyDeployApprovalModal({ ...it2, job: res, job_id: jobId, job_summary: runSummary });
                }
              } catch (err) {
                showToast(err.message || String(err), 'error', 6000);
              }
            } else {
              showToast('Approved', 'success');
            }

            maybeLoadSshKeyAdminQueue();
            loadAdminSshKeys();
          });
        });
        tbody.querySelectorAll('button[data-reject-id]').forEach(btn => {
          btn.addEventListener('click', async (e) => {
            e.preventDefault();
            const id = btn.getAttribute('data-reject-id');
            if (!id) return;
            const r2 = await fetch(`/sshkeys/admin/deploy-requests/${encodeURIComponent(id)}/reject`, { method: 'POST', credentials: 'include' });
            const raw = await r2.text();
            let data = null;
            try { data = raw ? JSON.parse(raw) : null; } catch { }
            if (!r2.ok) {
              const msg = (data && (data.detail || data.error)) ? (data.detail || data.error) : (raw || 'Reject failed');
              return showToast(msg, 'error');
            }
            showToast('Rejected', 'success');
            maybeLoadSshKeyAdminQueue();
            loadAdminSshKeys();
          });
        });
      } catch (e) {
        const indicator = document.getElementById('sshkeys-approval-indicator');
        if (indicator) indicator.style.display = 'none';
        tbody.innerHTML = `<tr><td colspan="5" style="text-align:center;color:#fca5a5;">${escapeHtml(e.message)}</td></tr>`;
      }
    }

    function initAuditDetailModalControls() {
      const modal = document.getElementById('audit-detail-modal');
      const closeBtn = document.getElementById('audit-detail-modal-close');
      const copyBtn = document.getElementById('audit-detail-modal-copy');
      const outEl = document.getElementById('audit-detail-modal-output');
      if (!modal) return;

      const close = () => {
        modal.classList.remove('open');
        modal.setAttribute('aria-hidden', 'true');
        modal.hidden = true;
      };

      closeBtn?.addEventListener('click', (e) => { e.preventDefault(); close(); });
      modal.addEventListener('click', (e) => { if (e.target && e.target.id === 'audit-detail-modal') close(); });
      document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && modal.classList.contains('open')) close(); });

      copyBtn?.addEventListener('click', async (e) => {
        e.preventDefault();
        const text = outEl ? (outEl.value || '') : '';
        try {
          await navigator.clipboard.writeText(text);
          showToast('Copied', 'success');
        } catch {
          if (outEl) {
            outEl.focus();
            outEl.select();
          }
          showToast('Copy failed (clipboard blocked). Text selected—press Ctrl/Cmd+C.', 'error', 5000);
        }
      });
    }

    function initHostActionControls() {
      document.getElementById('app-title')?.addEventListener('click', (e) => {
        e.preventDefault();
        showServerInfo();
      });
      document.getElementById('host-action-terminal')?.addEventListener('click', (e) => {
        e.preventDefault();
        showTerminal();
      });
      document.getElementById('host-action-users')?.addEventListener('click', (e) => {
        e.preventDefault();
        showUsers();
      });
      document.getElementById('host-action-services')?.addEventListener('click', (e) => {
        e.preventDefault();
        showServices();
      });
      document.getElementById('host-action-packages')?.addEventListener('click', (e) => {
        e.preventDefault();
        showPackages();
      });
    }

    function initSshKeysControls() {
      setupSshRefreshHandlers({
        loadSshKeys,
        maybeLoadSshKeyAdminQueue,
        loadAdminSshKeys,
        loadAdminUsers,
        loadAdminAudit,
      });
      document.getElementById('sshkey-approval-modal-close')?.addEventListener('click', (e) => { e.preventDefault(); closeSshKeyDeployApprovalModal(); });
      document.getElementById('sshkey-approval-modal')?.addEventListener('click', (e) => { if (e.target && e.target.id === 'sshkey-approval-modal') closeSshKeyDeployApprovalModal(); });

      document.getElementById('sshkey-add')?.addEventListener('click', async (e) => {
        e.preventDefault();
        await handleSshKeyAdd({
          statusEl: document.getElementById('sshkey-add-status'),
          loadSshKeys,
        });
      });

      setupSshHostPickerControls({
        setPanelVisible: setSshHostsPanelVisible,
        renderList: renderSshHostsList,
        selectAll: () => {
          const selectedAgentIds = getSshSelectedAgentIds();
          (allHosts || []).forEach(h => { if (h.agent_id) selectedAgentIds.add(h.agent_id); });
        },
        clearSelection: () => {
          setSshSelectedAgentIds(new Set());
        },
      });

      document.getElementById('sshkey-request-deploy')?.addEventListener('click', async (e) => {
        e.preventDefault();
        await handleSshRequestDeploy({
          statusEl: document.getElementById('sshkey-request-status'),
          selectedKeyId: getSshSelectedKeyId(),
          getSelectedAgentIds: () => Array.from(getSshSelectedAgentIds() || []),
          setPanelVisible: setSshHostsPanelVisible,
          renderList: renderSshHostsList,
          loadSshKeyRequests,
          maybeLoadSshKeyAdminQueue,
          loadAdminSshKeys,
        });
      });
    }
// Load hosts on page load
    initHostFilters();
    initFleetOverviewControls();
    initHostsTableControls();
    initCronjobsControls();
    initSshKeysControls();
    initLoadTimeframeControls();
    initPackagesSearch();
    initAdminPanel();
    initThemeToggle();
    initSettingsMenu();
    initHostActionControls();
    initAuditDetailModalControls();
    initTerminalOnce();
    attachTerminalInputHandlerOnce();
    initAnsibleSection();
    loadAuthInfo();

    // Disk details modal
    document.getElementById('disk-card')?.addEventListener('click', (e) => {
      e.preventDefault();
      if (!metricsLifecycleState.get('currentMetricsAgentId')) return;
      openDiskModal(metricsLifecycleState.get('currentMetricsAgentId'));
    });
    document.getElementById('disk-modal-close')?.addEventListener('click', (e) => { e.preventDefault(); closeDiskModal(); });
    document.getElementById('disk-modal')?.addEventListener('click', (e) => { if (e.target && e.target.id === 'disk-modal') closeDiskModal(); });

    document.getElementById('service-modal-close')?.addEventListener('click', (e) => { e.preventDefault(); closeServiceModal(); });
    document.getElementById('service-modal')?.addEventListener('click', (e) => { if (e.target && e.target.id === 'service-modal') closeServiceModal(); });

    document.getElementById('user-modal-close')?.addEventListener('click', (e) => { e.preventDefault(); closeUserModal(); });
    document.getElementById('user-modal')?.addEventListener('click', (e) => { if (e.target && e.target.id === 'user-modal') closeUserModal(); });
    const HOSTS_REFRESH_MS = 5000;
    let hostsRefreshTimer = null;

    function startHostRefresh() {
      if (hostsRefreshTimer) return;
      hostsRefreshTimer = setInterval(loadHosts, HOSTS_REFRESH_MS);
    }

    loadHosts();
    loadFleetOverview();
    startHostRefresh();
    setInterval(loadFleetOverview, 15000);
  </script>
</body>

</html>